## vim: filetype=makoada

-----------------------------
-- Defining_Names_Contains --
-----------------------------

function Decl_Defines
  (Context : Analysis_Context; Name : Text_Type) return Ada_Node_Predicate
is
   Ctx : constant Internal_Context := Unwrap_Context (Context);
begin
   return Result : Ada_Node_Predicate do
      Result.Set (Decl_Defines_Predicate'(Name => Lookup_Symbol (Ctx, Name)));
   end return;
end Decl_Defines;

--------------
-- Evaluate --
--------------

overriding function Evaluate
  (P : in out Decl_Defines_Predicate; N : Ada_Node) return Boolean
is
   use type Langkit_Support.Symbols.Symbol_Type;

   function Check_Base_Id (Id : Base_Id) return Boolean
   is (P_Sym (Bare_Single_Tok_Node (Unwrap_Node (Id))) = P.Name);
   --  Return whether the symbol for Id matches P.Name

begin
   if N.Is_Null or else N.Kind not in Ada_Basic_Decl then
      return False;
   end if;

   --  Look for at least one defining name that matches the expected name
   for Def_Name of N.As_Basic_Decl.P_Defining_Names loop
      declare
         N : constant Name := Def_Name.F_Name;
      begin
         case N.Kind is
            when Ada_Identifier | Ada_String_Literal =>
               if Check_Base_Id (N.As_Base_Id) then
                  return True;
               end if;

            when Ada_Dotted_Name =>
               if Check_Base_Id (N.As_Dotted_Name.F_Suffix) then
                  return True;
               end if;

            when others =>
               null;
         end case;
      end;
   end loop;

   return False;
end Evaluate;

-------------
-- Xref_Is --
-------------

function Xref_Is (Name : Defining_Name) return Ada_Node_Predicate is
begin
   return Result : Ada_Node_Predicate do
      Result.Set (Xref_Predicate'(Name => Name));
   end return;
end Xref_Is;

--------------
-- Evaluate --
--------------

overriding function Evaluate
  (P : in out Xref_Predicate; N : Ada_Node) return Boolean is
begin
   return not N.Is_Null and then N.P_Xref = P.Name;
exception
   when Property_Error =>
      return False;
end Evaluate;
