from __future__ import absolute_import

from langkit import compiled_types
from langkit.compiled_types import (
    ASTNode, BoolType, EnumType, Field, Struct, UserField, abstract,
    env_metadata, root_grammar_class, LongType, create_macro, LogicVarType,
    EquationType, T, LexicalEnvType, EnvElement
)

from langkit.envs import EnvSpec, add_to_env
from langkit.expressions import (
    AbstractProperty, And, Or, EmptyEnv, Env, EnvGroup, Literal, No, Not,
    langkit_property, Var, Bind, Let, New, Property, Self, EmptyArray, If,
    AbstractKind
)
from langkit.expressions.logic import (
    Predicate, LogicAnd, LogicOr, LogicTrue
)


def symbol_list(base_id_list):
    """
    Turn a list of BaseId into the corresponding array of symbols.

    :param AbstractExpression base_id_list: ASTList for the BaseId nodes to
        process.
    :rtype: AbstractExpression
    """
    return base_id_list.map(lambda base_id: base_id.tok.symbol)


@env_metadata
class Metadata(Struct):
    dottable_subprogram = UserField(
        BoolType, doc="Whether the stored element is a subprogram accessed "
                      "through the dot notation"
    )
    implicit_deref = UserField(
        BoolType, doc="Whether the stored element is accessed through an "
                      "implicit dereference"
    )


@abstract
@root_grammar_class
class AdaNode(ASTNode):
    """
    Root node class for the Ada grammar. This is good and necessary for several
    reasons:

    1. It will facilitate the sharing of langkit_support code if we ever have
       two libraries generated by LanguageKit in the same application.

    2. It allows to insert code specific to the ada root node, without
       polluting every LanguageKit node, and without bringing back the root
       ASTNode in the code templates.
    """

    ref_var = UserField(LogicVarType, is_private=True)
    type_var = UserField(LogicVarType, is_private=True)
    """
    Those two fields represents the result of the xref equations solving.

    TODO: They're probably not needed on every AdaNode, but are put here for
    the time being for convenience. We'll need to hoist them up the type chain
    at some point.
    """

    type_val = Property(
        Self.type_var.get_value,
        doc="""
        This will return the value of the type of this node after symbol
        resolution. NOTE: For this to be bound, resolve_symbols needs to be
        called on the appropriate parent node first.
        """
    )
    ref_val = Property(
        Self.ref_var.get_value,
        doc="""
        This will return the node this nodes references after symbol
        resolution. NOTE: For this to be bound, resolve_symbols needs to be
        called on the appropriate parent node first.
        """
    )

    @langkit_property(return_type=EquationType, private=True)
    def xref_equation(origin_env=LexicalEnvType):
        """
        This is the base property for constructing equations that, when solved,
        will resolve symbols and types for every sub expression of the
        expression you call it on. Note that if you call that on any
        expression, in some context it might lack full information and return
        multiple solutions. If you want completely precise resolution, you must
        call that on the outermost node that supports xref_equation.
        """
        # TODO: Maybe this should eventually be an AbstractProperty, but during
        # the development of the xref engine, it is practical to have the
        # default implementation return null, so that we can fail gracefully.
        return No(EquationType)

    xref_stop_resolution = Property(False, private=True)

    @langkit_property(return_type=EquationType, private=True)
    def sub_equation(origin_env=LexicalEnvType):
        """
        Wrapper for xref_equation, meant to be used inside of xref_equation
        when you want to get the sub equation of a sub expression. It is
        used to change the behavior when xref_equation is called from
        another xref_equation call, or from the top level, so that we can do
        resolution in several steps.
        """
        return If(Self.xref_stop_resolution,
                  LogicTrue(),
                  Self.xref_equation(origin_env))

    @langkit_property(return_type=BoolType, private=True)
    def resolve_symbols_internal(initial=BoolType):
        """
        Internal helper for resolve_symbols, implementing the recursive logic.
        """
        i = Var(If(initial | Self.xref_stop_resolution,
                   Self.xref_equation(Env).then(lambda x: x.solve),
                   True))

        j = Self.children.all(lambda c: c.then(
            lambda c: c.resolve_symbols_internal(False), default_val=True
        ))
        return i & j

    xref_entry_point = Property(False, doc="""
        Designates entities that are entry point for the xref solving
        infrastructure. If this returns true, then xref_equation can be
        called on it.
    """)

    @langkit_property(return_type=BoolType)
    def resolve_symbols():
        """
        This will resolve symbols for this node. If the operation is
        successful, then type_var and ref_var will be bound on appropriate
        subnodes of the statement.
        """
        return Self.resolve_symbols_internal(True)

    @langkit_property(return_type=BoolType)
    def is_visible_from(other=T.AdaNode):
        return Self.children_env.is_visible_from(other.children_env)


def child_unit(name_expr, scope_expr, env_val_expr=Self, is_body=False):
    """
    This macro will add the properties and the env specification necessary
    to make a node implement the specification of a library child unit in
    Ada, so that you can declare new childs to an unit outside of its own
    scope.

    :param AbstractExpression name_expr: The expression that will retrieve
        the name symbol for the decorated node.

    :param AbstractExpression scope_expr: The expression that will retrieve the
        scope node for the decorated node.

    :param AbstractExpression env_val_expr: The expression that will
        retrieve the environment value for the decorated node.

    :param bool is_body: Whether this unit is a body. If it is, the environment
        hook will try to make the corresponding spec's environment its parent.

    :rtype: NodeMacro
    """

    attribs = dict(
        scope=Property(scope_expr, private=True, doc="""
                       Helper property, that will return the scope of
                       definition of this child unit.
                       """),
        env_spec=EnvSpec(
            initial_env=Self.scope, add_env=True,
            add_to_env=add_to_env(name_expr, env_val_expr),
            env_hook_arg=(Self if is_body else None),
        )
    )

    return create_macro(attribs)


@abstract
class BasicDecl(AdaNode):
    defining_names = AbstractProperty(type=T.Name.array_type())
    defining_name = Property(Self.defining_names.at(0))
    defining_env = Property(
        EmptyEnv, private=True,
        doc="""
        Return a lexical environment that contains entities that are accessible
        as suffixes when Self is a prefix.
        """
    )

    array_ndims = Property(
        Literal(0),
        doc="""
        If this designates an entity with an array-like interface, return its
        number of dimensions. Return 0 otherwise.
        """
    )

    is_array = Property(Self.array_ndims > 0)
    is_subp = Property(Self.is_a(T.BasicSubprogramDecl, T.SubprogramBody))

    expr_type = Property(
        Self.type_expression.then(lambda te: te.designated_type),
        type=T.TypeDecl,
        doc="""
        Return the type declaration corresponding to this basic declaration
        has when it is used in an expression context. For example, for this
        basic declaration::

            type Int is range 0 .. 100;

            A : Int := 12;

        the declaration of the Int type will be returned. For this
        declaration::

            type F is delta 0.01 digits 10;

            function B return F;

        expr_type will return the declaration of the type F.
        """
    )

    type_expression = AbstractProperty(
        type=T.TypeExpression,
        runtime_check=True,
        doc="""
        Return the type expression for this BasicDecl if applicable, a null
        otherwise.
        """
    )

    type_designator = Property(Let(lambda te=Self.type_expression: If(
        Not(te.is_null), te.cast(AdaNode), Self.expr_type.cast(AdaNode),
    )), doc="""
        Return the type designator for this BasicDecl. This will either be a
        TypeExpression instance, if applicable to this BasicDecl, or a
        TypeDecl.
        """
    )

    array_def = Property(
        Self.expr_type.array_def,
        doc="""
        Return the ArrayTypeDef instance corresponding to this basic
        declaration.
        """
    )

    @langkit_property(return_type=T.TypeDecl)
    def canonical_expr_type():
        """
        Same as expr_type, but will instead return the canonical type
        declaration.
        """
        return Self.expr_type.then(lambda t: t.canonical_type)

    @langkit_property(return_type=T.SubprogramSpec)
    def subp_spec():
        """
        If node is a Subprogram, returns the specification of this subprogram.
        TODO: Enhance when we have interfaces.
        """
        return Self.match(
            lambda subp=BasicSubprogramDecl: subp.subp_spec,
            lambda subp=SubprogramBody:      subp.subp_spec,
            lambda others:                   No(SubprogramSpec),
        )

    @langkit_property(return_type=EquationType, private=True)
    def constrain_prefix(prefix=T.Expr):
        """
        This method is used when self is a candidate suffix in a dotted
        expression, to express the potential constraint that the suffix could
        express on the prefix.

        For example, given this code::

            1 type P is record
            2     A, B : Integer;
            3 end record;
            4
            5 P_Inst : P;
            7
            8 P_Inst.A;
              ^^^^^^^^

        A references the A ComponentDecl at line 2, and the constraint that we
        want to express on the prefix (P_Inst), is that it needs to be of type
        P.
        """
        # Default implementation returns logic true => does not add any
        # constraint to the xref equation.
        return LogicTrue()

    declarative_scope = Property(
        Self.parents.find(
            lambda p: p.is_a(T.DeclarativePart)
        ).cast(T.DeclarativePart),
        doc="Return the scope of definition of this basic declaration."
    )


@abstract
class Body(BasicDecl):
    pass


@abstract
class BodyStub(Body):
    pass


class DiscriminantSpec(BasicDecl):
    ids = Field(type=T.Identifier.list_type())
    type_expr = Field(type=T.TypeExpression)
    default_expr = Field(type=T.Expr)

    env_spec = EnvSpec(add_to_env=add_to_env(symbol_list(Self.ids), Self))

    defining_names = Property(Self.ids.map(lambda id: id.cast(T.Name)))


class TypeDiscriminant(AdaNode):
    discr_specs = Field(type=T.DiscriminantSpec.list_type())


@abstract
class TypeDef(AdaNode):
    array_ndims = Property(
        Literal(0),
        doc="""
        If this designates an array type, return its number of dimensions.
        Return 0 otherwise.
        """
    )

    is_real_type = Property(False, doc="Whether type is a real type or not.")
    is_int_type = Property(False,
                           doc="Whether type is an integer type or not.")
    is_access_type = Property(False,
                              doc="Whether type is an access type or not.")
    is_char_type = Property(False)

    accessed_type = Property(No(T.TypeDecl))
    is_tagged_type = Property(False, doc="Whether type is tagged or not")
    base_type = Property(
        No(T.TypeDecl), doc="""
        Return the base type entity for this derived type definition.
        """
    )

    defining_env = Property(EmptyEnv)


class Variant(AdaNode):
    choice_list = Field(type=T.AdaNode.list_type())
    components = Field(type=T.ComponentList)


class VariantPart(AdaNode):
    discr_name = Field(type=T.Identifier)
    variant = Field(type=T.Variant.list_type())


@abstract
class AbstractFormalParamDecl(BasicDecl):
    """
    Represent an abstract formal parameter declaration. This is used both
    for records components and for subprogram parameters.
    """
    identifiers = AbstractProperty(type=T.Identifier.list_type())
    type_expression = AbstractProperty(type=T.TypeExpression)
    is_mandatory = Property(False)


class ComponentDecl(AbstractFormalParamDecl):
    ids = Field(type=T.Identifier.list_type())
    component_def = Field(type=T.ComponentDef)
    default_expr = Field(type=T.Expr)
    aspects = Field(type=T.AspectSpecification)

    env_spec = EnvSpec(add_to_env=add_to_env(symbol_list(Self.ids), Self))

    identifiers = Property(Self.ids)
    defining_env = Property(
        Self.component_def.type_expr.defining_env,
        private=True,
        doc="See BasicDecl.defining_env"
    )

    defining_names = Property(Self.ids.map(lambda id: id.cast(T.Name)))
    array_ndims = Property(Self.component_def.type_expr.array_ndims)

    type_expression = Property(Self.component_def.type_expr)

    @langkit_property(return_type=EquationType, private=True)
    def constrain_prefix(prefix=T.Expr):
        return (
            # Simple type equivalence
            (prefix.type_var == Self.container_type)

            # Access dereference
            | Predicate(TypeDecl.fields.matching_prefix_type,
                        prefix.type_var, Self.container_type)
        )

    @langkit_property(return_type=T.TypeDecl)
    def container_type():
        """
        Return the defining container type for this component declaration.
        """
        return Self.parents.find(lambda p: p.is_a(TypeDecl)).cast(TypeDecl)


@abstract
class AbstractFormalParamHolder(AdaNode):
    """
    Represents the abstract holder of a list of formal parameters. This is
    used both for subprogram specifications and for records, so that we can
    share the matching and unpacking logic.
    """

    abstract_formal_params = AbstractProperty(
        type=AbstractFormalParamDecl.array_type(),
        doc="Return the list of abstract formal parameters for this holder."
    )

    unpacked_formal_params = Property(
        Self.abstract_formal_params.mapcat(
            lambda profile: profile.identifiers.map(lambda id: (
                New(SingleFormal, name=id, profile=profile)
            ))
        ),
        doc='Couples (identifier, param profile) for all parameters'
    )

    @langkit_property(return_type=T.ParamMatch.array_type())
    def match_param_list(params=T.ParamList, is_dottable_subp=BoolType):
        """
        For each ParamAssoc in a ParamList, return whether we could find a
        matching formal in Self, and whether this formal is optional (i.e. has
        a default value).
        """
        def matches(formal, actual):
            return New(ParamMatch,
                       has_matched=True,
                       formal=formal,
                       actual=actual)

        unpacked_formals = Var(Self.unpacked_formal_params)

        return params.unpacked_params.map(lambda i, a: If(
            a.name.is_null,

            Let(lambda idx=If(is_dottable_subp, i + 1, i):
                # Positional parameter case: if this parameter has no
                # name association, make sure we have enough formals.
                unpacked_formals.at(idx).then(lambda sp: matches(sp, a))),

            # Named parameter case: make sure the designator is
            # actualy a name and that there is a corresponding
            # formal.
            a.name.then(lambda id: (
                unpacked_formals.find(lambda p: p.name.matches(id)).then(
                    lambda sp: matches(sp, a)
                )
            ))
        ))


class ComponentList(AbstractFormalParamHolder):
    components = Field(type=T.AdaNode.list_type())
    variant_part = Field(type=T.VariantPart)

    type_def = Property(Self.parent.parent.cast(T.TypeDef))

    parent_component_list = Property(
        Self.type_def.cast(T.DerivedTypeDef).then(
            lambda dtd: dtd.base_type.record_def.components
        )
    )

    @langkit_property()
    def abstract_formal_params():
        # TODO: Incomplete definition. We need to:
        # 1. Handle variant parts.
        # 2. Concatenate parent components.
        pcl = Var(Self.parent_component_list)
        self_comps = Var(Self.components.filtermap(
            filter_expr=lambda p: p.is_a(AbstractFormalParamDecl),
            expr=lambda p: p.cast(AbstractFormalParamDecl)
        ))

        return If(
            pcl.is_null,
            self_comps,
            pcl.abstract_formal_params.concat(self_comps)
        )


class RecordDef(AdaNode):
    components = Field(type=T.ComponentList)


class RecordTypeDef(TypeDef):
    abstract = Field(type=T.BoolType)
    tagged = Field(type=T.BoolType)
    limited = Field(type=T.BoolType)
    record_def = Field(type=T.RecordDef)

    defining_env = Property(
        # We don't want to be able to access env elements in parents,
        # so we orphan the env.
        Self.children_env.env_orphan
    )

    is_tagged_type = Property(Self.tagged)


@abstract
class RealTypeDef(TypeDef):
    is_real_type = Property(True)


@abstract
class TypeDecl(BasicDecl):
    type_id = Field(type=T.Identifier)

    name = Property(Self.type_id)
    env_spec = EnvSpec(add_to_env=add_to_env(Self.type_id.name.symbol, Self))

    defining_names = Property(Self.type_id.cast(T.Name).singleton)

    is_real_type = Property(False, doc="Whether type is a real type or not.")
    is_int_type = Property(False, doc="Whether type is an integer type or not")

    is_access_type = Property(False,
                              doc="Whether type is an access type or not")

    is_char_type = Property(False,
                            doc="Whether type is a character type or not")

    is_str_type = Property(
        Self.is_array & Self.component_type.then(lambda ct: ct.is_char_type)
    )

    accessed_type = Property(No(T.TypeDecl))
    is_tagged_type = Property(False, doc="Whether type is tagged or not")
    base_type = Property(
        No(T.TypeDecl), doc="""
        Return the base type entity for this derived type declaration.
        """
    )
    array_def = Property(No(T.ArrayTypeDef))
    record_def = Property(No(T.RecordDef))

    component_type = Property(
        Self.array_def.then(lambda atd: atd.component_type),
        doc="""
        Return the component type of the type, if applicable. The
        component type is the type you'll get if you call an instance of the
        Self type. So it can either be:
        1. The component type for an array
        2. The return type for an access to function
        """
    )

    # A TypeDecl in an expression context corresponds to a type conversion, so
    # its type is itself.
    expr_type = Property(Self)

    @langkit_property(return_type=BoolType)
    def is_derived_type(other_type=T.TypeDecl):
        """
        Whether Self is derived from other_type.
        """
        return Or(
            Self.base_type == other_type,
            Self.base_type.then(lambda base_type:
                                base_type.is_derived_type(other_type))
        )

    @langkit_property(return_type=BoolType)
    def matching_prefix_type(container_type=T.TypeDecl):
        """
        Given a dotted expression A.B, where container_type is the container
        type for B, and Self is a potential type for A, returns whether Self is
        a valid type for A in the dotted expression.
        """
        return (
            # Simple access type case
            (Self.canonical_type.accessed_type
             == container_type.canonical_type)

            # Derived type case
            | Self.canonical_type.is_derived_type(
                container_type.canonical_type
            )

            # Access to derived type case
            | Self.canonical_type.accessed_type.then(
                lambda a: a.is_derived_type(container_type.canonical_type)
            )
        )

    @langkit_property(return_type=T.TypeDecl)
    def canonical_type():
        """
        Return the canonical type declaration for this type declaration. For
        subtypes, it will return the base type declaration.
        """
        return Self

    @langkit_property(return_type=BoolType)
    def is_primitive(spec=T.SubprogramSpec):
        """
        Whether the passed SubprogramSpec corresponds to a primitive of the
        type Self represents.
        """
        t_expr = Var(spec.params.at(0).type_expr)
        return (
            (t_expr.designated_type == Self)
            | t_expr.type_expr_variant.cast(TypeAccessExpression).then(
                lambda tae: tae.accessed_type == Self
            )
        )

    primitives = Property(
        Self.declarative_scope.primitives(Self), doc="""
        Return all primitives for Self. Note that this will only return a
        correct result if the source is a correct Ada file. TODO: Not complete.
        Needs to look at private part.
        """
    )

    tagged_primitives = Property(
        If(Self.is_tagged_type, Self.primitives, EmptyArray(BasicDecl)), doc="""
        Helper. Returns primitives for type if type is tagged, empty array
        otherwise.
        """
    )


class FullTypeDecl(TypeDecl):
    discriminants = Field(type=T.TypeDiscriminant)
    type_def = Field(type=T.TypeDef)
    aspects = Field(type=T.AspectSpecification)

    array_ndims = Property(Self.type_def.array_ndims)

    is_real_type = Property(Self.type_def.is_real_type)
    is_int_type = Property(Self.type_def.is_int_type)
    is_access_type = Property(Self.type_def.is_access_type)
    accessed_type = Property(Self.type_def.accessed_type)
    is_tagged_type = Property(Self.type_def.is_tagged_type)
    base_type = Property(Self.type_def.base_type)

    array_def = Property(Self.type_def.cast(T.ArrayTypeDef))

    defining_env = Property(
        # Evaluating in type env, because the defining environment of a type
        # is always its own.
        Self.children_env.eval_in_env(Self.type_def.defining_env)

        # TODO: The fact that the env should not be inherited from the called
        # property might be common enough to warrant a specific construct, such
        # as a kw parameter to Property: inherit_caller_env=False - or even
        # make it the default, and only inherit the env when explicitly
        # specified.
    )

    env_spec = EnvSpec(add_env=True)

    record_def = Property(
        Self.type_def.match(
            lambda r=T.RecordTypeDef: r.record_def,
            lambda d=T.DerivedTypeDef: d.record_extension,
            lambda _: No(T.RecordDef)
        )
    )


class EnumTypeDecl(TypeDecl):
    enum_literals = Field(type=T.EnumLiteralDecl.list_type())
    aspects = Field(type=T.AspectSpecification)

    is_char_type = Property(Self.enum_literals.any(
        lambda lit: lit.enum_identifier.is_a(T.CharLiteral)
    ))


class FloatingPointDef(RealTypeDef):
    num_digits = Field(type=T.Expr)
    range = Field(type=T.Expr)


class OrdinaryFixedPointDef(RealTypeDef):
    delta = Field(type=T.Expr)
    range = Field(type=T.Expr)


class DecimalFixedPointDef(RealTypeDef):
    delta = Field(type=T.Expr)
    digits = Field(type=T.Expr)
    range = Field(type=T.Expr)


@abstract
class Constraint(AdaNode):
    pass


class RangeConstraint(Constraint):
    range = Field(type=T.Expr)


class DigitsConstraint(Constraint):
    digits = Field(type=T.Expr)
    range = Field(type=T.Expr)


class DeltaConstraint(Constraint):
    digits = Field(type=T.Expr)
    range = Field(type=T.Expr)


class IndexConstraint(Constraint):
    constraints = Field(type=T.AdaNode.list_type())


class DiscriminantConstraint(Constraint):
    constraints = Field(type=T.DiscriminantAssociation.list_type())


class DiscriminantAssociation(Constraint):
    ids = Field(type=T.Identifier.list_type())
    expr = Field(type=T.Expr)


class DerivedTypeDef(TypeDef):
    abstract = Field(type=T.BoolType)
    limited = Field(type=T.BoolType)
    synchronized = Field(type=T.BoolType)
    null_exclusion = Field(type=T.BoolType)
    name = Field(type=T.TypeExpression)
    constraint = Field(type=T.Constraint)
    interfaces = Field(type=T.Name.list_type())
    record_extension = Field(type=T.RecordDef)
    has_private_part = Field(type=T.BoolType)

    array_ndims = Property(Self.name.array_ndims)

    base_type = Property(Self.name.designated_type)

    is_real_type = Property(Self.base_type.is_real_type)
    is_int_type = Property(Self.base_type.is_int_type)
    is_access_type = Property(Self.base_type.is_access_type)
    is_char_type = Property(Self.base_type.is_char_type)
    accessed_type = Property(Self.base_type.accessed_type)
    is_tagged_type = Property(True)

    defining_env = Property(EnvGroup(
        Self.children_env.env_orphan,

        # Add environments from parent type defs
        Self.name.designated_type.canonical_type.defining_env
    ))


class IncompleteTypeDef(TypeDef):
    is_tagged = Field(type=T.BoolType)

    is_tagged_type = Property(Self.is_tagged)
    # TODO: what should we return for array_ndims? Do we need to find the full
    # view?


class PrivateTypeDef(TypeDef):
    abstract = Field(type=T.BoolType)
    tagged = Field(type=T.BoolType)
    limited = Field(type=T.BoolType)

    # TODO: what should we return for array_ndims? Do we need to find the full
    # view?


class SignedIntTypeDef(TypeDef):
    range = Field(type=T.Expr)
    is_int_type = Property(True)


class ModIntTypeDef(TypeDef):
    expr = Field(type=T.Expr)
    is_int_type = Property(True)


@abstract
class ArrayIndices(AdaNode):
    ndims = AbstractProperty(
        type=LongType,
        doc="""Number of dimensions described in this node."""
    )

    @langkit_property(private=True, return_type=EquationType)
    def constrain_index_expr(index_expr=T.Expr, dim=LongType):
        """
        Add a constraint on an expression passed as the index of an array
        access expression.

        For example::

            type A is array (Integer range 1 .. 10) of Integer;

            A_Inst : A;

            A_Inst (2);
            --      ^ Will add constraint on lit that it needs to be of type
            --      Integer.
        """
        return LogicTrue()


class UnconstrainedArrayIndices(ArrayIndices):
    types = Field(type=T.Name.list_type())
    ndims = Property(Self.types.length)

    @langkit_property(return_type=EquationType)
    def constrain_index_expr(index_expr=T.Expr, dim=LongType):
        return (
            index_expr.type_var ==
            Self.types.at(dim).designated_type.canonical_type
        )


class ConstrainedArrayIndices(ArrayIndices):
    list = Field(type=T.AdaNode.list_type())

    ndims = Property(Self.list.length)

    @langkit_property(return_type=EquationType)
    def constrain_index_expr(index_expr=T.Expr, dim=LongType):
        return Self.list.at(dim).match(
            lambda te=TypeExpression:
            index_expr.type_var == te.designated_type.canonical_type,

            # TODO: We need to parse Standard to express the fact that when
            # we've got an anonymous range in the array index definition,
            # the index needs to be of type Standard.Integer.
            lambda _: LogicTrue()
        )


class ComponentDef(AdaNode):
    aliased = Field(type=T.BoolType)
    type_expr = Field(type=T.TypeExpression)


class ArrayTypeDef(TypeDef):
    indices = Field(type=T.ArrayIndices)
    stored_component = Field(type=T.ComponentDef)

    component_type = Property(
        Self.stored_component.type_expr.designated_type.canonical_type,
        doc="Returns the type stored as a component in the array"
    )

    array_ndims = Property(Self.indices.ndims)


class InterfaceKind(EnumType):
    alternatives = ["limited", "task", "protected", "synchronized"]
    suffix = 'interface'


class InterfaceTypeDef(TypeDef):
    interface_kind = Field(type=T.InterfaceKind)
    interfaces = Field(type=T.Name.list_type())


class SubtypeDecl(TypeDecl):
    type_expr = Field(type=T.TypeExpression)
    aspects = Field(type=T.AspectSpecification)

    array_ndims = Property(Self.type_expr.array_ndims)
    defining_env = Property(Self.type_expr.defining_env)

    canonical_type = Property(Self.type_expr.designated_type.canonical_type)

    accessed_type = Property(Self.canonical_type.accessed_type)


class TaskDef(AdaNode):
    interfaces = Field(type=T.Name.list_type())
    public_part = Field(type=T.PublicPart)
    private_part = Field(type=T.PrivatePart)
    end_id = Field(type=T.Identifier)


class ProtectedDef(AdaNode):
    public_part = Field(type=T.PublicPart)
    private_part = Field(type=T.PrivatePart)
    end_id = Field(type=T.Identifier)


class TaskTypeDecl(BasicDecl):
    task_type_name = Field(type=T.Identifier)
    discrs = Field(type=T.TypeDiscriminant)
    aspects = Field(type=T.AspectSpecification)
    definition = Field(type=T.TaskDef)

    defining_names = Property(Self.task_type_name.cast(T.Name).singleton)


class ProtectedTypeDecl(BasicDecl):
    protected_type_name = Field(type=T.Identifier)
    discrs = Field(type=T.TypeDiscriminant)
    aspects = Field(type=T.AspectSpecification)
    interfaces = Field(type=T.Name.list_type())
    definition = Field(type=T.ProtectedDef)

    defining_names = Property(Self.protected_type_name.cast(T.Name).singleton)


class AccessDef(TypeDef):
    not_null = Field(type=T.BoolType)
    access_expr = Field(type=T.AccessExpression)
    constraint = Field(type=T.Constraint)

    is_access_type = Property(True)
    accessed_type = Property(Self.access_expr.accessed_type)

    defining_env = Property(Self.accessed_type.defining_env)


class FormalDiscreteTypeDef(TypeDef):
    pass


class NullComponentDecl(AdaNode):
    pass


class WithDecl(AdaNode):
    is_limited = Field(type=T.BoolType)
    is_private = Field(type=T.BoolType)
    packages = Field(type=T.Name.list_type())

    env_spec = EnvSpec(env_hook_arg=Self)


@abstract
class UseDecl(AdaNode):
    pass


class UsePkgDecl(UseDecl):
    packages = Field(type=T.Name.list_type())


class UseTypDecl(UseDecl):
    all = Field(type=T.BoolType)
    types = Field(type=T.Expr.list_type())


class TypeExpression(AdaNode):
    """
    This type will be used as a base for what represents a type expression
    in the Ada syntax tree.
    """
    null_exclusion = Field(type=T.BoolType)
    type_expr_variant = Field(type=T.TypeExprVariant)

    array_def = Property(Self.type_expr_variant.match(
        lambda aa=T.AnonymousArray: aa.array_def,
        lambda _: Self.designated_type.then(lambda dt: dt.array_def)
    ))

    array_ndims = Property(Self.type_expr_variant.match(
        lambda aa=T.AnonymousArray: aa.array_def.array_ndims,
        lambda _: Self.designated_type.then(
            lambda dt: dt.array_ndims, default_val=0
        )
    ))

    component_type = Property(Self.type_expr_variant.match(
        lambda aa=T.AnonymousArray: aa.array_def.component_type,
        lambda _: Self.designated_type.then(
            lambda dt: dt.component_type,
        )
    ), doc="""
        Return the component_type of the type expression, if applicable. See
        TypeDecl for more details.
        """
    )

    defining_env = Property(
        Self.type_expr_variant.defining_env, private=True,
        doc='Helper for BaseDecl.defining_env'
    )

    designated_type = Property(
        Self.type_expr_variant.designated_type,
        doc="Shortcut to get at the designated type of the type expression"
    )

    accessed_type = Property(
        Self.type_expr_variant.cast(T.TypeAccessExpression).then(
            lambda tae: tae.accessed_type
        )
    )

    @langkit_property(return_type=TypeDecl)
    def element_type():
        """
        If self is an anonymous access, return the accessed type. Otherwise,
        return the designated type.
        """
        d = Self.designated_type
        return If(d.is_null, Self.accessed_type, d)


@abstract
class TypeExprVariant(AdaNode):
    defining_env = Property(
        EmptyEnv, private=True,
        doc='Helper for BaseDecl.defining_env'
    )

    designated_type = AbstractProperty(
        type=TypeDecl, runtime_check=True, doc="""
        Return the type designated by this type expression.
        """
    )


class AnonymousArray(TypeExprVariant):
    array_def = Field(type=T.ArrayTypeDef)


class TypeRef(TypeExprVariant):
    name = Field(type=T.Expr)
    constraint = Field(type=T.Constraint)

    # The name for this type has to be evaluated in the context of the TypeRef
    # node itself: we don't want to use whatever lexical environment the caller
    # is using.
    designated_type = Property(
        Self.node_env.eval_in_env(Self.name.designated_type)
    )

    defining_env = Property(Self.designated_type.defining_env)


@abstract
class AccessExpression(TypeExprVariant):
    # TODO? Should we handle defining_env here for implicit dereferencing?

    accessed_type = Property(No(TypeDecl))

    # TODO: Implement designated_type (which will need resolution of anonymous
    # access types first).
    designated_type = Property(No(TypeDecl))


class SubprogramAccessExpression(AccessExpression):
    is_protected = Field(repr=False)
    subp_spec = Field(type=T.SubprogramSpec)
    accessed_type = Property(No(TypeDecl))


class TypeAccessExpression(AccessExpression):
    is_all = Field(type=T.BoolType)
    is_constant = Field(type=T.BoolType)
    subtype_name = Field(type=T.Expr)
    accessed_type = Property(Self.subtype_name.designated_type)


class ParameterProfile(AbstractFormalParamDecl):
    ids = Field(type=T.Identifier.list_type())
    is_aliased = Field(type=T.BoolType)
    mode = Field(type=T.InOut)
    type_expr = Field(type=T.TypeExpression)
    default = Field(type=T.Expr)

    identifiers = Property(Self.ids)
    is_mandatory = Property(Self.default.is_null)
    defining_names = Property(Self.ids.map(lambda id: id.cast(T.Name)))

    env_spec = EnvSpec(add_to_env=add_to_env(symbol_list(Self.ids), Self))

    type_expression = Property(Self.type_expr)


class AspectSpecification(AdaNode):
    aspect_assocs = Field(type=T.AspectAssoc.list_type())


class BasicSubprogramDecl(BasicDecl):
    is_overriding = Field(type=T.Overriding)
    subp_spec = Field(type=T.SubprogramSpec)

    name = Property(Self.subp_spec.name)
    defining_names = Property(Self.subp_spec.name.singleton)
    defining_env = Property(Self.subp_spec.defining_env)

    type_expression = Property(
        Self.subp_spec.returns, doc="""
        The expr type of a subprogram declaration is the return type of the
        subprogram if the subprogram is a function.
        """
    )

    env_spec = EnvSpec(
        initial_env=Self.subp_spec.name.scope,
        add_to_env=[
            # First regular add to env action, adding to the subp's scope
            add_to_env(Self.subp_spec.name.name.symbol, Self),

            # Second custom action, adding to the type's environment if the
            # type is tagged and self is a primitive of it.
            add_to_env(
                key=Self.subp_spec.name.name.symbol,
                val=Self.subp_spec.dottable_subprogram,
                dest_env=Self.subp_spec.potential_dottable_type.then(
                    lambda t: t.children_env
                ),
                # We pass custom metadata, marking the entity as a dottable
                # subprogram.
                metadata=New(Metadata, dottable_subprogram=True,
                             implicit_deref=False),
                is_post=True
            ),
        ],
        add_env=True
    )


class SubprogramDecl(BasicSubprogramDecl):
    aspects = Field(type=T.AspectSpecification)


class NullSubprogramDecl(BasicSubprogramDecl):
    aspects = Field(type=T.AspectSpecification)


class AbstractSubprogramDecl(BasicSubprogramDecl):
    aspects = Field(type=T.AspectSpecification)


class ExpressionFunction(BasicSubprogramDecl):
    expression = Field(type=T.Expr)
    aspects = Field(type=T.AspectSpecification)


class RenamingSubprogramDecl(BasicSubprogramDecl):
    renames = Field(type=T.RenamingClause)
    aspects = Field(type=T.AspectSpecification)


class Pragma(AdaNode):
    id = Field(type=T.Identifier)
    args = Field(type=T.PragmaArgument.list_type())


class PragmaArgument(AdaNode):
    id = Field(type=T.Identifier)
    expr = Field(type=T.Expr)


######################
# GRAMMAR DEFINITION #
######################

class InOut(EnumType):
    alternatives = ["in", "out", "inout"]
    suffix = 'way'


@abstract
class AspectClause(AdaNode):
    pass


class EnumRepClause(AspectClause):
    type_name = Field(type=T.Name)
    aggregate = Field(type=T.Aggregate)


class AttributeDefClause(AspectClause):
    attribute_expr = Field(type=T.Expr)
    expr = Field(type=T.Expr)


class RecordRepComponent(AdaNode):
    id = Field(type=T.Identifier)
    position = Field(type=T.Expr)
    range = Field(type=T.Expr)


class RecordRepClause(AspectClause):
    component_name = Field(type=T.Name)
    at_expr = Field(type=T.Expr)
    components = Field(type=T.RecordRepComponent.list_type())


class AtClause(AspectClause):
    name = Field(type=T.SingleTokNode)
    expr = Field(type=T.Expr)


class EntryDecl(BasicDecl):
    overriding = Field(type=T.Overriding)
    entry_id = Field(type=T.Identifier)
    family_type = Field(type=T.AdaNode)
    params = Field(type=T.ParameterProfile.list_type())
    aspects = Field(type=T.AspectSpecification)

    defining_names = Property(Self.entry_id.cast(T.Name).singleton)


class TaskDecl(BasicDecl):
    task_name = Field(type=T.Identifier)
    aspects = Field(type=T.AspectSpecification)
    definition = Field(type=T.TaskDef)

    defining_names = Property(Self.task_name.cast(T.Name).singleton)


class ProtectedDecl(BasicDecl):
    protected_name = Field(type=T.Identifier)
    aspects = Field(type=T.AspectSpecification)
    definition = Field(type=T.ProtectedDef)

    defining_names = Property(Self.protected_name.cast(T.Name).singleton)


class AspectAssoc(AdaNode):
    id = Field(type=T.Expr)
    expr = Field(type=T.Expr)


class NumberDecl(BasicDecl):
    ids = Field(type=T.Identifier.list_type())
    expr = Field(type=T.Expr)

    defining_names = Property(Self.ids.map(lambda id: id.cast(T.Name)))


class ObjectDecl(BasicDecl):
    ids = Field(type=T.Identifier.list_type())
    aliased = Field(type=T.BoolType)
    constant = Field(type=T.BoolType)
    inout = Field(type=T.InOut)
    type_expr = Field(type=T.TypeExpression)
    default_expr = Field(type=T.Expr)
    renaming_clause = Field(type=T.RenamingClause)
    aspects = Field(type=T.AspectSpecification)

    env_spec = EnvSpec(add_to_env=add_to_env(symbol_list(Self.ids), Self))

    array_ndims = Property(Self.type_expr.array_ndims)
    array_def = Property(Self.type_expr.array_def)

    defining_names = Property(Self.ids.map(lambda id: id.cast(T.Name)))

    defining_env = Property(Self.type_expr.defining_env)

    type_expression = Property(Self.type_expr)

    @langkit_property()
    def xref_equation(origin_env=LexicalEnvType):
        return (
            Self.default_expr.then(lambda de: de.xref_equation(origin_env),
                                   default_val=LogicTrue())
            & (Self.default_expr.type_var == Self.canonical_expr_type)
        )

    xref_entry_point = Property(True)


class DeclarativePart(AdaNode):
    decls = Field(type=T.AdaNode.list_type())

    @langkit_property(return_type=BasicDecl.array_type())
    def primitives(t=TypeDecl):
        """
        Return all potential primitive operations for t in the scope of Self.
        """
        return Self.decls.filtermap(
            filter_expr=lambda decl: decl.match(
                lambda s=BasicSubprogramDecl: t.is_primitive(s.subp_spec),
                lambda s=SubprogramBody: t.is_primitive(s.subp_spec),
                lambda others: False,
            ),
            expr=lambda decl: decl.cast_or_raise(BasicDecl)
        )


class PrivatePart(DeclarativePart):
    env_spec = EnvSpec(add_env=True)


class PublicPart(DeclarativePart):
    pass


class BasePackageDecl(BasicDecl):
    """
    Package declarations. Concrete instances of this class
    will be created in generic package declarations. Other non-generic
    package declarations will be instances of PackageDecl.

    The behavior is the same, the only difference is that BasePackageDecl
    and PackageDecl have different behavior regarding lexical environments.
    In the case of generic package declarations, we use BasePackageDecl
    which has no env_spec, and the environment behavior is handled by the
    GenericPackageDecl instance.
    """
    package_name = Field(type=T.Name)
    aspects = Field(type=T.AspectSpecification)
    public_part = Field(type=T.PublicPart)
    private_part = Field(type=T.PrivatePart)
    end_id = Field(type=T.Name)

    name = Property(Self.package_name, private=True)
    defining_names = Property(Self.name.singleton)
    defining_env = Property(Self.children_env.env_orphan)


class PackageDecl(BasePackageDecl):
    """
    Non-generic package declarations.
    """
    _macros = [child_unit(Self.package_name.name.symbol,
                          Self.package_name.scope)]


class ExceptionDecl(BasicDecl):
    """
    Exception declarations.
    """
    ids = Field(type=T.Identifier.list_type())
    renames = Field(type=T.RenamingClause)
    aspects = Field(type=T.AspectSpecification)
    defining_names = Property(Self.ids.map(lambda id: id.cast(T.Name)))


@abstract
class GenericInstantiation(BasicDecl):
    """
    Instantiations of generics.
    """
    name = Field(type=T.Name)
    generic_entity_name = Field(type=T.Name)
    parameters = Field(type=T.AdaNode)
    aspects = Field(type=T.AspectSpecification)
    defining_names = Property(Self.name.singleton)


class GenericProcedureInstantiation(GenericInstantiation):
    pass


class GenericFunctionInstantiation(GenericInstantiation):
    pass


class GenericPackageInstantiation(GenericInstantiation):
    pass


class RenamingClause(AdaNode):
    """
    Renaming clause, used everywhere renamings are valid.
    """
    renamed_object = Field(type=T.Expr)


class PackageRenamingDecl(BasicDecl):
    name = Field(type=T.Name)
    renames = Field(type=RenamingClause)
    aspects = Field(type=T.AspectSpecification)

    defining_names = Property(Self.name.singleton)


class GenericRenamingDecl(BasicDecl):
    name = Field(type=T.Name)
    renames = Field(type=T.Name)
    aspects = Field(type=T.AspectSpecification)

    defining_names = Property(Self.name.singleton)


class FormalSubpDecl(BasicDecl):
    """
    Formal subprogram declarations, in generic declarations formal parts.
    """
    subp_spec = Field(type=T.SubprogramSpec)
    is_abstract = Field(type=T.BoolType)
    default_value = Field(type=T.Expr)
    aspects = Field(type=T.AspectSpecification)

    defining_names = Property(Self.subp_spec.name.singleton)


class Overriding(EnumType):
    alternatives = ["overriding", "not_overriding", "unspecified"]
    suffix = 'kind'


class GenericSubprogramDecl(BasicDecl):
    formal_part = Field(type=T.AdaNode.list_type())
    subp_spec = Field(type=T.SubprogramSpec)
    aspects = Field(type=T.AspectSpecification)

    defining_names = Property(Self.subp_spec.name.singleton)


class GenericPackageDecl(BasicDecl):
    _macros = [child_unit(Self.package_name.name.symbol,
                          Self.package_name.scope)]

    formal_part = Field(type=T.AdaNode.list_type())
    package_decl = Field(type=BasePackageDecl)

    package_name = Property(Self.package_decl.package_name)

    defining_names = Property(Self.package_name.singleton)


def is_package(e):
    """
    Property helper to determine if an entity is a package or not.

    :type e: AbstractExpression
    :rtype: AbstractExpression
    """
    return Not(e.is_null) & e.is_a(PackageDecl, PackageBody)


def is_library_package(e):
    """
    Property helper to determine if an entity is a library level package or
    not.

    :type e: AbstractExpression
    :rtype: AbstractExpression
    """
    return Not(e.is_null) & is_package(e) & e.parent.is_a(LibraryItem)


@abstract
class Expr(AdaNode):

    @langkit_property(kind=AbstractKind.abstract_runtime_check, private=True,
                      return_type=LexicalEnvType)
    def designated_env(origin_env=LexicalEnvType):
        """
        Returns the lexical environment designated by this name.

        If this name involves overloading, this will return a combination of
        the various candidate lexical environments.
        """
        pass

    scope = AbstractProperty(
        type=compiled_types.LexicalEnvType, private=True, runtime_check=True,
        doc="""
        Returns the lexical environment that is the scope in which the
        entity designated by this name is defined/used.
        """
    )

    name = AbstractProperty(
        type=compiled_types.Token, private=True, runtime_check=True,
        doc="""
        Returns the relative name of this instance. For example,
        for a prefix A.B.C, this will return C.
        """
    )

    env_elements = Property(Self.env_elements_impl(Env))

    @langkit_property(private=True,
                      return_type=EnvElement.array_type(),
                      kind=AbstractKind.abstract_runtime_check)
    def env_elements_impl(origin_env=LexicalEnvType):
        """
        Returns the list of annotated elements in the lexical environment
        that can statically be a match for expr before overloading analysis.
        """
        pass

    entities = Property(
        Self.env_elements.map(lambda e: e.el), type=AdaNode.array_type(),
        doc="""
        Same as env_elements, but return bare AdaNode instances rather than
        EnvElement instances.
        """
    )

    designated_type = AbstractProperty(
        type=TypeDecl, runtime_check=True,
        doc="""
        Assuming this expression designates a type, return this type.

        Since in Ada this can be resolved locally without any non-local
        analysis, this doesn't use logic equations.
        """
    )


class UnOp(Expr):
    op = Field(type=T.Op)
    expr = Field(type=T.Expr)


class BinOp(Expr):
    left = Field(type=T.Expr)
    op = Field(type=T.Op)
    right = Field(type=T.Expr)


class MembershipExpr(Expr):
    expr = Field(type=T.Expr)
    op = Field(type=T.Op)
    membership_exprs = Field(type=T.AdaNode.list_type())


class Aggregate(Expr):
    ancestor_expr = Field(type=T.Expr)
    assocs = Field(type=T.ParamList)

    xref_stop_resolution = Property(True)

    @langkit_property()
    def xref_equation(origin_env=LexicalEnvType):
        td = Var(Self.type_val.cast(TypeDecl))
        atd = Var(td.array_def)
        return LogicAnd(If(
            atd.is_null,

            # First case, aggregate for a record
            td.record_def.components.match_param_list(Self.assocs, False).map(
                lambda pm:
                (pm.actual.assoc.expr.type_var
                 == pm.formal.profile.type_expression.designated_type)
                & pm.actual.assoc.expr.sub_equation(origin_env)
                & If(pm.actual.name.is_null,
                     LogicTrue(),
                     pm.actual.name.ref_var == pm.formal.profile)
            ),

            # Second case, aggregate for an array
            Self.assocs.params.map(
                lambda assoc:
                assoc.expr.sub_equation(origin_env)
                & (assoc.expr.type_var == atd.component_type)
            )
        ))


class CallExpr(Expr):
    name = Field(type=T.Expr)
    suffix = Field(type=T.AdaNode)

    @langkit_property()
    def designated_env(origin_env=LexicalEnvType):
        return Self.entities().map(lambda e: e.match(
            lambda subp=BasicSubprogramDecl: subp.defining_env,
            lambda subp=SubprogramBody:      subp.defining_env,
            lambda others:                   EmptyEnv,
        )).env_group

    @langkit_property()
    def env_elements_impl(origin_env=LexicalEnvType):
        return Self.name.env_elements_impl(origin_env)

    # CallExpr can appear in type expressions: they are used to create implicit
    # subtypes for discriminated records or arrays.
    designated_type = Property(Self.name.designated_type)

    params = Property(Self.suffix.cast(T.ParamList))

    @langkit_property(return_type=EquationType)
    def xref_equation(origin_env=LexicalEnvType):
        return If(
            Not(Self.name.designated_type.is_null),

            # Type conversion case
            Self.type_conv_xref_equation(origin_env),

            # General case. We'll call general_xref_equation on the innermost
            # call expression, to handle nested call expression cases.
            Self.innermost_callexpr.general_xref_equation(origin_env)
        )

    @langkit_property(return_type=EquationType, private=True)
    def type_conv_xref_equation(origin_env=LexicalEnvType):
        """
        Helper for xref_equation, handles construction of the equation in type
        conversion cases.
        """
        return And(
            Self.params.params.at(0).expr.sub_equation(origin_env),
            Self.name.sub_equation(origin_env),
            Self.type_var == Self.name.type_var,
            Self.ref_var == Self.name.ref_var
        )

    @langkit_property(return_type=EquationType, private=True)
    def general_xref_equation(origin_env=LexicalEnvType):
        """
        Helper for xref_equation, handles construction of the equation in
        subprogram call cases.
        """
        # List of every applicable subprogram
        subps = Var(Self.env_elements)

        return (
            Self.name.sub_equation(origin_env)
            # TODO: For the moment we presume that a CallExpr in an expression
            # context necessarily has a ParamList as a suffix, but this is not
            # always true (for example, entry families calls). Handle the
            # remaining cases.
            & LogicAnd(Self.params.params.map(
                lambda pa: pa.expr.sub_equation(origin_env)
            ))

            # For each potential subprogram match, we want to express the
            # following constraints:
            & LogicOr(subps.map(lambda e: Let(lambda s=e.el.cast(BasicDecl): (

                # The called entity is the subprogram
                (Self.name.ref_var == s)

                & If(
                    # Test if the entity is a parameterless subprogram call,
                    # or something else (a component/local variable/etc),
                    # that would make this callexpr an array access.
                    s.subp_spec.then(lambda ss: ss.parameterless(e.MD),
                                     default_val=True),

                    Self.equation_for_type(origin_env, s.type_designator),

                    # The type of the expression is the expr_type of the
                    # subprogram.
                    (Self.type_var == s.expr_type)
                    # For each parameter, the type of the expression matches
                    # the expected type for this subprogram.
                    & LogicAnd(s.subp_spec.match_param_list(
                        Self.params, e.MD.dottable_subprogram
                    ).map(
                        lambda pm: (
                            # The type of each actual matches the type of the
                            # formal.
                            pm.actual.assoc.expr.type_var == pm.formal
                            .profile.type_expression.designated_type

                        ) & If(
                            # Bind actuals designators to parameters if there
                            # are designators.
                            pm.actual.name.is_null,
                            LogicTrue(),
                            pm.actual.name.ref_var
                            == pm.formal.profile
                        )
                    ))
                )
                # For every callexpr between self and the furthest callexpr
                # that is an ancestor of Self via the name chain, we'll
                # construct the crossref equation.
                & Self.parent_nested_callexpr.then(
                    lambda pce: pce.parent_callexprs_equation(
                        origin_env,
                        Self.type_component(s.type_designator)
                    ), default_val=LogicTrue()
                )
            ))))

            # Bind the callexpr's ref_var to the id's ref var.
            # TODO: Not sure yet we want to propagate ref_vars everywhere, or
            # just keep them in identifiers. Maybe we want a property
            # "references" that just returns the info.
            # Pros:
            # * Less memory use because we can put ref_var in BaseId.
            # * Less complicated equations code and runtime.
            & (Self.ref_var == Self.name.ref_var)
        )

    @langkit_property(return_type=EquationType, private=True)
    def equation_for_type(origin_env=LexicalEnvType, type_designator=AdaNode):
        """
        Construct an equation verifying if Self is conformant to the type
        designator passed in parameter.
        """
        atd = Var(type_designator.match(
            lambda te=TypeExpression: te.array_def,
            lambda td=TypeDecl: td.array_def,
            lambda _: No(ArrayTypeDef)
        ))

        return Let(lambda indices=atd.indices: LogicAnd(
            Self.params.params.map(lambda i, pa: (
                pa.expr.sub_equation(origin_env)
                & indices.constrain_index_expr(pa.expr, i)
            ))
        )) & (Self.type_var == atd.component_type)

    @langkit_property(return_type=BoolType)
    def check_type_self(type_designator=AdaNode):
        """
        Internal helper for check_type. Implements the logic for the current
        node only. TODO: Waiting on interfaces.
        """
        # TODO: Interface for type designator would be of course 100* better
        # TODO 2: For the moment this is specialized for arrays, but we need to
        # handle the case when the return value is an access to subprogram.
        return type_designator.match(
            lambda te=TypeExpression: te.array_ndims,
            lambda td=TypeDecl: td.array_ndims,
            lambda _: -1
        ) == Self.suffix.cast_or_raise(ParamList).params.length

    @langkit_property(return_type=AdaNode)
    def type_component(type_designator=AdaNode):
        """
        Helper to return the type component of a Node that can be either a
        TypeDecl or a TypeExpression. TODO: Waiting on interfaces.
        """
        return type_designator.match(
            lambda te=TypeExpression: te.component_type,
            lambda td=TypeDecl: td.component_type,
            lambda _: No(AdaNode)
        )

    @langkit_property(return_type=BoolType)
    def check_type_internal(type_designator=AdaNode):
        """
        Internal helper for check_type. Will call check_type_self on Self and
        all parent CallExprs.
        """
        return And(
            Self.check_type_self(type_designator),
            Self.parent.cast(T.CallExpr).then(
                lambda ce: ce.check_type_internal(
                    Self.type_component(type_designator)
                ), default_val=True
            )
        )

    @langkit_property(return_type=BoolType)
    def check_type(type_designator=AdaNode):
        """
        Verifies that this callexpr is valid for the type designated by
        type_designator. type_designator is either a TypeDecl or a
        TypeExpression. TODO: Waiting on interfaces.
        """
        # Algorithm: We're:
        # 1. Taking the innermost call expression
        # 2. Recursing down call expression and component types up to self,
        # checking for each level that the call expression corresponds.
        return Self.innermost_callexpr.check_type_internal(type_designator)

    @langkit_property(return_type=T.CallExpr)
    def innermost_callexpr():
        """
        Helper property. Will return the innermost call expression following
        the name chain. For, example, given::
            A (B) (C) (D)
            ^-----------^ Self
            ^-------^     Self.name
            ^---^         Self.name.name

        Self.innermost_callexpr will return the node corresponding to
        Self.name.name.
        """
        return Self.name.cast(T.CallExpr).then(
            lambda ce: ce.innermost_callexpr(), default_val=Self
        )

    @langkit_property(return_type=T.CallExpr)
    def parent_nested_callexpr():
        """
        Will return the parent callexpr iff Self is the name of the parent
        callexpr.
        """
        return Self.parent.cast(T.CallExpr).then(
            lambda ce: If(ce.name == Self, ce, No(CallExpr))
        )

    @langkit_property(return_type=EquationType, private=True)
    def parent_callexprs_equation(origin_env=LexicalEnvType,
                                  designator_type=AdaNode):
        """
        Construct the xref equation for the chain of parent nested callexprs.
        """
        return (
            Self.equation_for_type(origin_env, designator_type)
            & Self.parent_nested_callexpr.then(
                lambda pce: pce.parent_callexprs_equation(
                    origin_env,
                    Self.type_component(designator_type)
                ), default_val=LogicTrue()
            )
        )


class ParamAssoc(AdaNode):
    designator = Field(type=T.AdaNode)
    expr = Field(type=T.Expr)


class ParamList(AdaNode):
    params = Field(type=T.ParamAssoc.list_type())

    @langkit_property()
    def unpacked_params():
        """
        Given the list of ParamAssoc, that can in certain case designate
        several actual parameters at once, create an unpacked list of
        SingleActual instances.
        """
        return Self.params.mapcat(
            lambda pa: pa.designator.then(lambda des: des.match(
                lambda i=Identifier:
                    New(SingleActual, name=i, assoc=pa).singleton,
                lambda ag=AggregateMember:
                    ag.choice_list.filtermap(
                        filter_expr=lambda n: n.is_a(T.Identifier),
                        expr=lambda i:
                        New(SingleActual, name=i.cast(T.Identifier),
                            assoc=pa)
                    ),
                lambda _:
                New(SingleActual, name=No(Identifier), assoc=pa).singleton
            ), default_val=New(SingleActual,
                               name=No(T.Identifier), assoc=pa).singleton)
        )


class AccessDeref(Expr):
    prefix = Field(type=T.Expr)

    @langkit_property()
    def designated_env(origin_env=LexicalEnvType):
        # Since we have implicit dereference in Ada, everything is directly
        # accessible through the prefix, so we just use the prefix's env.
        return Self.prefix.designated_env(origin_env)

    @langkit_property()
    def env_elements_impl(origin_env=LexicalEnvType):
        return Self.prefix.env_elements_impl(origin_env).filter(
            # Env elements for access derefs need to be of an access type
            lambda e: e.el.cast(BasicDecl).then(
                lambda bd: bd.canonical_expr_type.is_access_type()
            )
        )

    @langkit_property()
    def xref_equation(origin_env=LexicalEnvType):
        return (
            Self.prefix.sub_equation(origin_env)
            # Evaluate the prefix equation

            & Self.ref_var.domain(Self.entities)
            # Restrict the domain of the reference to entities that are of an
            # access type.

            & (Self.ref_var == Self.prefix.ref_var)
            # Propagate this constraint upward to the prefix expression

            & Bind(Self.prefix.type_var,
                   Self.type_var,
                   TypeDecl.fields.accessed_type)
            # We don't need to check if the type is an access type, since we
            # already constrained the domain above.
        )


class DiamondExpr(Expr):
    pass


class OthersDesignator(AdaNode):
    pass


class AggregateMember(AdaNode):
    choice_list = Field(type=T.AdaNode.list_type())


class Op(EnumType):
    """Operation in a binary expression."""
    alternatives = ["and", "or", "or_else", "and_then", "xor", "in",
                    "not_in", "abs", "not", "pow", "mult", "div", "mod",
                    "rem", "plus", "minus", "bin_and", "eq", "neq", "lt",
                    "lte", "gt", "gte", "ellipsis"]
    suffix = 'op'


class IfExpr(Expr):
    cond_expr = Field(type=T.Expr)
    then_expr = Field(type=T.Expr)
    elsif_list = Field(type=T.ElsifExprPart.list_type())
    else_expr = Field(type=T.Expr)


class ElsifExprPart(AdaNode):
    cond_expr = Field(type=T.Expr)
    then_expr = Field(type=T.Expr)


class CaseExpr(Expr):
    expr = Field(type=T.Expr)
    cases = Field(type=T.CaseExprAlternative.list_type())


class CaseExprAlternative(Expr):
    choices = Field(type=T.AdaNode.list_type())
    expr = Field(type=T.Expr)


@abstract
class Name(Expr):

    env_for_scope = Property(
        EmptyEnv,
        doc="""
        Lexical environment this identifier represents. This is similar to
        designated_env although it handles only cases for child units and it is
        used only during the environment population pass so it does not return
        orphan environments.
        """
    )


@abstract
class SingleTokNode(Name):
    tok = Field(type=T.Token)

    name = Property(Self.tok)

    @langkit_property(return_type=BoolType)
    def matches(other=T.SingleTokNode):
        """
        Return whether this token and the "other" one are the same.
        This is only defined for two nodes that wrap symbols.

        """
        return Self.name.symbol == other.name.symbol


@abstract
class BaseId(SingleTokNode):

    env_for_scope = Property(Env.resolve_unique(Self.tok).el.match(
        lambda decl=T.PackageDecl: decl.children_env,
        lambda body=T.PackageBody: body.children_env,
        lambda others:             EmptyEnv
    ))

    @langkit_property()
    def designated_env(origin_env=LexicalEnvType):
        return Self.designated_env_impl(origin_env, False)

    @langkit_property(private=True)
    def designated_env_impl(origin_env=LexicalEnvType, is_parent_pkg=BoolType):
        """
        Decoupled implementation for designated_env, specifically used by
        DottedName when the parent is a library level package.
        """
        ents = Var(Self.env_elements_baseid(origin_env, is_parent_pkg))

        return Let(lambda el=ents.at(0).el: If(
            is_package(el),
            el.cast(BasicDecl).defining_env,
            ents.map(lambda e: e.el.cast(BasicDecl).defining_env).env_group
        ))

    scope = Property(Env)
    name = Property(Self.tok)

    designated_type = Property(
        # We don't use get_sequential here because declaring two types with
        # the same name in the same scope is an error in Ada, except in the
        # case of incomplete types forward declarations, and in that case
        # we want the complete view anyway.
        # TODO: For correct semantics and xref, we still want to implement
        # correct support, so that references to the incomplete type don't
        # reference the complete type. This is low priority but still needs
        # to be done.
        Env.get(Self.tok).at(0).el.cast(TypeDecl)
    )

    @langkit_property(return_type=CallExpr)
    def parent_callexpr():
        """
        If this BaseId is the main symbol qualifying the prefix in a call
        expression, this returns the corresponding CallExpr node. Return null
        otherwise. For example::

            C (12, 15);
            ^ parent_callexpr = <CallExpr>

            A.B.C (12, 15);
                ^ parent_callexpr = <CallExpr>

            A.B.C (12, 15);
              ^ parent_callexpr = null

            C (12, 15);
               ^ parent_callexpr = null
        """
        return Self.parents.take_while(lambda p: Or(
            p.is_a(CallExpr),
            p.is_a(DottedName, BaseId) & p.parent.match(
                lambda pfx=DottedName: pfx.suffix == p,
                lambda ce=CallExpr: ce.name == p,
                lambda _: False
            )
        )).find(lambda p: p.is_a(CallExpr)).cast(CallExpr)

    @langkit_property()
    def env_elements_impl(origin_env=LexicalEnvType):
        return Self.env_elements_baseid(origin_env, False)

    @langkit_property(private=True)
    def env_elements_baseid(origin_env=LexicalEnvType, is_parent_pkg=BoolType):
        """
        Decoupled implementation for env_elements_impl, specifically used by
        designated_env when the parent is a library level package.
        """
        items = Var(Env.get_sequential(Self.tok))
        pc = Var(Self.parent_callexpr)

        def matching_subp(params, subp, env_el):
            # Either the subprogram has is matching the CallExpr's parameters
            return subp.subp_spec.is_matching_param_list(
                params, env_el.MD.dottable_subprogram
                # Or the subprogram is parameterless, and the returned
                # component (s) matches the callexpr (s).
            ) | subp.expr_type.then(lambda et: (
                subp.subp_spec.parameterless(env_el.MD)
                & pc.check_type(et)
            ))

        return If(
            pc.is_null,

            # If it is not the main id in a CallExpr: either the name
            # designates something else than a subprogram, either it designates
            # a subprogram that accepts no explicit argument. So filter out
            # other subprograms.
            items.filter(lambda e: (
                # If we're at the visibilty checking point (parent is a package
                # and self is not), we want to check whether the requester has
                # visibility over the element.
                If(is_parent_pkg & Not(is_library_package(e.el)),
                   Env.is_visible_from(origin_env),
                   True)

                & e.el.cast_or_raise(BasicDecl).subp_spec.then(
                    # If there is a subp_spec, check that it corresponds to
                    # a parameterless subprogram.
                    lambda ss: ss.parameterless(e.MD),
                    default_val=True
                )
            )),

            # This identifier is the name for a called subprogram or an array.
            # So only keep:
            # * subprograms for which the actuals match;
            # * arrays for which the number of dimensions match.
            pc.suffix.cast(ParamList).then(lambda params: (
                items.filter(lambda e: e.el.match(
                    lambda subp=BasicSubprogramDecl:
                        matching_subp(params, subp, e),

                    lambda subp=SubprogramBody:
                        matching_subp(params, subp, e),

                    # Type conversion case
                    lambda t=TypeDecl: params.params.length == 1,

                    # In the case of ObjectDecls/BasicDecls in general, verify
                    # that the callexpr is valid for the given type designator.
                    lambda o=ObjectDecl: pc.check_type(o.type_expr),
                    lambda b=BasicDecl: pc.check_type(b.expr_type),

                    lambda _: False
                ))
            ), default_val=items)
        )

    @langkit_property()
    def xref_equation(origin_env=LexicalEnvType):
        dt = Self.designated_type
        return If(
            Not(dt.is_null),

            # Type conversion case
            (Self.ref_var == dt) & (Self.type_var == dt),

            # Other cases
            Self.ref_var.domain(Self.entities)
            & Bind(Self.ref_var, Self.type_var,
                   BasicDecl.fields.canonical_expr_type)
        )


class Identifier(BaseId):
    _repr_name = "Id"


class StringLiteral(BaseId):
    _repr_name = "Str"

    @langkit_property()
    def xref_equation(origin_env=LexicalEnvType):
        return Predicate(TypeDecl.fields.is_str_type, Self.type_var)


class EnumLiteralDecl(BasicDecl):
    enum_identifier = Field(type=T.BaseId)

    @langkit_property(return_type=T.TypeDecl)
    def canonical_expr_type():
        return Self.parents.find(lambda p: p.is_a(TypeDecl)).cast(TypeDecl)

    defining_names = Property(Self.enum_identifier.cast(T.Name).singleton)

    env_spec = EnvSpec(
        add_to_env=add_to_env(Self.enum_identifier.tok.symbol, Self)
    )


class CharLiteral(BaseId):
    _repr_name = "Chr"

    @langkit_property()
    def xref_equation(origin_env=LexicalEnvType):
        return Predicate(TypeDecl.fields.is_char_type, Self.type_var)


class NumLiteral(SingleTokNode):
    _repr_name = "Num"


class DecLiteral(NumLiteral):
    _repr_name = "Dec"

    @langkit_property()
    def xref_equation(origin_env=LexicalEnvType):
        return Predicate(TypeDecl.fields.is_real_type, Self.type_var)


class IntLiteral(NumLiteral):
    _repr_name = "Int"

    @langkit_property()
    def xref_equation(origin_env=LexicalEnvType):
        return Predicate(TypeDecl.fields.is_int_type, Self.type_var)


class NullLiteral(SingleTokNode):
    _repr_name = "Null"


class Attribute(SingleTokNode):
    _repr_name = "Attr"


class SingleFormal(Struct):
    name = Field(type=Identifier)
    profile = Field(type=AbstractFormalParamDecl)


class SingleActual(Struct):
    name = Field(type=Identifier)
    assoc = Field(type=T.ParamAssoc)


class ParamMatch(Struct):
    """
    Helper data structure to implement SubprogramSpec/ParamAssocList matching.

    Each value relates to one ParamAssoc.
    """
    has_matched = Field(type=BoolType, doc="""
        Whether the matched ParamAssoc a ParameterProfile.
    """)
    actual = Field(type=SingleActual)
    formal = Field(type=SingleFormal)


class SubprogramSpec(AbstractFormalParamHolder):
    name = Field(type=T.Name)
    params = Field(type=T.ParameterProfile.list_type())
    returns = Field(type=T.TypeExpression)

    abstract_formal_params = Property(
        Self.params.map(lambda p: p.cast(AbstractFormalParamDecl))
    )

    nb_min_params = Property(
        Self.unpacked_formal_params.filter(
            lambda p: p.profile.is_mandatory
        ).length,
        type=LongType, doc="""
        Return the minimum number of parameters this subprogram can be called
        while still being a legal call.
        """
    )

    nb_max_params = Property(
        Self.unpacked_formal_params.length, type=LongType,
        doc="""
        Return the maximum number of parameters this subprogram can be called
        while still being a legal call.
        """
    )

    @langkit_property(return_type=BoolType)
    def is_matching_param_list(params=ParamList, is_dottable_subp=BoolType):
        """
        Return whether a ParamList is a match for this SubprogramSpec, i.e.
        whether the argument count (and designators, if any) match.
        """
        match_list = Var(Self.match_param_list(params, is_dottable_subp))
        nb_max_params = If(is_dottable_subp, Self.nb_max_params - 1,
                           Self.nb_max_params)
        nb_min_params = If(is_dottable_subp, Self.nb_min_params - 1,
                           Self.nb_min_params)

        return And(
            params.params.length <= nb_max_params,
            match_list.all(lambda m: m.has_matched),
            match_list.filter(
                lambda m: m.formal.profile.is_mandatory
            ).length == nb_min_params,
        )

    @langkit_property(return_type=BoolType)
    def match_param_assoc(pa=ParamAssoc):
        """
        Return whether some parameter association matches an argument in this
        subprogram specification. Note that this matching disregards types: it
        only considers arity and designators (named parameters).
        """
        # Parameter associations can match only if there is at least one
        # formal in this spec.
        return (Self.nb_max_params > 0) & (
            # Then, all associations with no designator match, as we don't
            # consider types.
            Not(pa.designator.is_null)

            # The ones with a designator match iff the designator is an
            # identifier whose name is present in the list of formals.
            | pa.designator.cast(Identifier).then(
                lambda id: Self.unpacked_formal_params.any(
                    lambda p: p.name.matches(id)
                )
            )
        )

    @langkit_property(return_type=compiled_types.LexicalEnvType, private=True)
    def defining_env():
        """
        Helper for BasicDecl.defining_env.
        """
        return If(Self.returns.is_null, EmptyEnv, Self.returns.defining_env)

    @langkit_property(return_type=TypeDecl)
    def potential_dottable_type():
        """
        If self meets the criterias for being a subprogram callable via the dot
        notation, return the type of dottable elements.
        """
        return Self.params.at(0).type_expr.then(lambda te: te.element_type)

    @langkit_property(return_type=T.BasicDecl.array_type())
    def dottable_subprogram():
        """
        Used for environments. Returns either an empty array, or an array
        containg the subprogram declaration for this spec, if self meets the
        criterias for being a dottable subprogram.
        """
        bd = Var(Self.parent.cast_or_raise(BasicDecl))
        return If(
            And(
                Self.nb_max_params > 0,
                Self.potential_dottable_type.then(lambda t: And(
                    # Dot notation only works on tagged types
                    t.is_tagged_type,

                    Or(
                        # Needs to be declared in the same scope as the type
                        t.declarative_scope == bd.declarative_scope,

                        # Or in the private part corresponding to the type's
                        # public part. TODO: This is invalid because it will
                        # make private subprograms visible from the outside.
                        t.declarative_scope == bd.declarative_scope.parent
                        .cast(PackageDecl).then(lambda pd: pd.public_part)
                    )
                ))
            ),
            bd.singleton,
            EmptyArray(T.BasicDecl)
        )

    @langkit_property(return_type=BoolType, private=True)
    def parameterless(md=Metadata):
        """
        Utility function. Given a subprogram spec and its associated metadata,
        determine if it can be called without parameters (and hence without a
        callexpr).
        """
        return Or(
            md.dottable_subprogram & (Self.nb_min_params == 1),
            Self.nb_min_params == 0
        )


class Quantifier(EnumType):
    alternatives = ["all", "some"]
    suffix = 'items'


class IterType(EnumType):
    alternatives = ["in", "of"]
    suffix = 'iter'


@abstract
class LoopSpec(AdaNode):
    pass


class ForLoopSpec(LoopSpec):
    id = Field(type=T.Identifier)
    loop_type = Field(type=T.IterType)
    is_reverse = Field(type=T.BoolType)
    iter_expr = Field(type=T.AdaNode)


class QuantifiedExpr(Expr):
    quantifier = Field(type=T.Quantifier)
    loop_spec = Field(type=T.ForLoopSpec)
    expr = Field(type=T.Expr)


class Allocator(Expr):
    subpool = Field(type=T.Expr)
    expr = Field(type=T.AdaNode)


class QualExpr(Expr):
    prefix = Field(type=T.Expr)
    suffix = Field(type=T.Expr)

    @langkit_property(return_type=EquationType)
    def xref_equation(origin_env=LexicalEnvType):
        typ = Self.prefix.designated_type.canonical_type

        return (
            Self.suffix.sub_equation(origin_env)
            & (Self.prefix.ref_var == typ)
            & (Self.prefix.type_var == typ)
            & (Self.suffix.type_var == typ)
            & (Self.type_var == typ)
        )


class AttributeRef(Expr):
    prefix = Field(type=T.Expr)
    attribute = Field(type=T.SingleTokNode)
    args = Field(type=T.AdaNode)

    designated_type = Property(Self.prefix.designated_type)


class RaiseExpression(Expr):
    exception_name = Field(type=T.Expr)
    error_message = Field(type=T.Expr)


class DottedName(Name):
    prefix = Field(type=T.Expr)
    suffix = Field(type=T.SingleTokNode)

    @langkit_property()
    def designated_env(origin_env=LexicalEnvType):
        pfx_env = Var(Self.prefix.designated_env(origin_env))
        return pfx_env.eval_in_env(If(
            is_library_package(pfx_env.env_node) & Self.suffix.is_a(T.BaseId),
            Self.suffix.cast(BaseId).designated_env_impl(origin_env, True),
            Self.suffix.designated_env(origin_env)
        ))

    env_for_scope = Property(Self.suffix.cast(BaseId).then(
        lambda sfx: Self.scope.eval_in_env(sfx.env_for_scope),
        default_val=EmptyEnv
    ))

    scope = Property(Self.prefix.match(
        lambda name=T.Name: name.env_for_scope,
        lambda others:      EmptyEnv
    ))

    name = Property(Self.suffix.name)

    @langkit_property()
    def env_elements_impl(origin_env=LexicalEnvType):
        pfx_env = Var(Self.prefix.designated_env(origin_env))

        return pfx_env.eval_in_env(If(
            is_library_package(pfx_env.env_node) & Self.suffix.is_a(T.BaseId),
            Self.suffix.cast(BaseId).env_elements_baseid(origin_env, True),
            Self.suffix.env_elements_impl(origin_env)
        ))

    potential_primitive_calls = Property(Self.prefix.entities.mapcat(
        lambda e: e.cast(BasicDecl).expr_type.tagged_primitives.filter(
            lambda p: p.defining_name.cast_or_raise(SingleTokNode).matches(
                Self.suffix
            )
        )),
        doc="Return all potential primitive calls Self can correspond to."
    )

    designated_type = Property(lambda: (
        Self.prefix.entities.at(0).children_env.eval_in_env(
            Self.suffix.designated_type
        )
    ))

    @langkit_property()
    def xref_equation(origin_env=LexicalEnvType):
        dt = Self.designated_type
        base = Var(
            Self.prefix.sub_equation(origin_env)
            & Self.prefix.designated_env(origin_env).eval_in_env(
                Self.suffix.sub_equation(origin_env)
            )
        )
        return If(
            Not(dt.is_null),
            base,
            base & LogicOr(Self.entities.map(lambda e: (
                (Self.suffix.ref_var == e)
                & e.cast(BasicDecl).constrain_prefix(Self.prefix)
                & (Self.type_var == Self.suffix.type_var)
            )))
        )


class CompilationUnit(AdaNode):
    """Root node for all Ada analysis units."""
    prelude = Field(doc="``with``, ``use`` or ``pragma`` statements.")
    body = Field(type=T.AdaNode)
    pragmas = Field(type=T.Pragma.list_type())


class SubprogramBody(Body):
    _macros = [child_unit(Self.subp_spec.name.name.symbol,
                          Self.subp_spec.name.scope,
                          Self,
                          is_body=True)]

    overriding = Field(type=T.Overriding)
    subp_spec = Field(type=T.SubprogramSpec)
    aspects = Field(type=T.AspectSpecification)
    decls = Field(type=T.DeclarativePart)
    statements = Field(type=T.HandledStatements)
    end_id = Field(type=T.Expr)

    defining_names = Property(Self.subp_spec.name.singleton)
    defining_env = Property(Self.subp_spec.defining_env)


class HandledStatements(AdaNode):
    statements = Field(type=T.AdaNode.list_type())
    exceptions = Field(type=T.ExceptionHandler.list_type())


class ExceptionHandler(AdaNode):
    exc_name = Field(type=T.Identifier)
    catched_exceptions = Field(type=T.AdaNode.list_type())
    statements = Field(type=T.AdaNode.list_type())


@abstract
class Statement(AdaNode):
    pass


@abstract
class SimpleStatement(Statement):
    xref_entry_point = Property(True)


@abstract
class CompositeStatement(Statement):
    pass


class CallStatement(SimpleStatement):
    call = Field(type=T.Expr)

    @langkit_property()
    def xref_equation(origin_env=LexicalEnvType):
        return (
            Self.call.sub_equation(origin_env)

            # Call statements can have no return value
            & (Self.call.type_var == No(AdaNode))
        )


class NullStatement(SimpleStatement):
    null_lit = Field(repr=False)


class AssignStatement(SimpleStatement):
    dest = Field(type=T.Expr)
    expr = Field(type=T.Expr)

    @langkit_property()
    def xref_equation(origin_env=LexicalEnvType):
        return (
            Self.dest.sub_equation(origin_env)
            # TODO: Handle more complex cases than pure type equality,
            # eg. tagged types, accesses.
            & Self.expr.sub_equation(origin_env)
            & (Self.expr.type_var == Self.dest.type_var)
        )


class GotoStatement(SimpleStatement):
    label_name = Field(type=T.Name)


class ExitStatement(SimpleStatement):
    loop_name = Field(type=T.Identifier)
    condition = Field(type=T.Expr)


class ReturnStatement(SimpleStatement):
    return_expr = Field(type=T.AdaNode)


class RequeueStatement(SimpleStatement):
    call_name = Field(type=T.Expr)
    with_abort = Field(type=T.BoolType)


class AbortStatement(SimpleStatement):
    names = Field(type=T.Expr.list_type())


class DelayStatement(SimpleStatement):
    until = Field(type=T.BoolType)
    expr = Field(type=T.Expr)


class RaiseStatement(SimpleStatement):
    exception_name = Field(type=T.Expr)
    error_message = Field(type=T.Expr)


class IfStatement(CompositeStatement):
    condition = Field(type=T.Expr)
    statements = Field(type=T.AdaNode.list_type())
    alternatives = Field(type=T.ElsifStatementPart.list_type())
    else_statements = Field(type=T.AdaNode.list_type())


class ElsifStatementPart(AdaNode):
    expr = Field(type=T.Expr)
    statements = Field(type=T.AdaNode.list_type())


class Label(SimpleStatement):
    token = Field(type=T.Token)


class WhileLoopSpec(LoopSpec):
    expr = Field(type=T.Expr)


class LoopStatement(CompositeStatement):
    name = Field(type=T.Identifier)
    spec = Field(type=T.LoopSpec)
    statements = Field(type=T.AdaNode.list_type())


class BlockStatement(CompositeStatement):
    name = Field(type=T.Identifier)
    decls = Field(type=T.AdaNode.list_type())
    statements = Field(type=T.HandledStatements)

    env_spec = EnvSpec(add_env=True)


class ExtendedReturnStatement(CompositeStatement):
    object_decl = Field(type=T.ObjectDecl)
    statements = Field(type=T.HandledStatements)


class CaseStatement(CompositeStatement):
    case_expr = Field(type=T.Expr)
    case_alts = Field(type=T.CaseStatementAlternative.list_type())


class CaseStatementAlternative(AdaNode):
    choices = Field(type=T.AdaNode.list_type())
    statements = Field(type=T.AdaNode.list_type())


class AcceptStatement(CompositeStatement):
    name = Field(type=T.Identifier)
    entry_index_expr = Field(type=T.Expr)
    parameters = Field(type=T.ParameterProfile.list_type())
    statements = Field(type=T.HandledStatements)


class SelectStatement(CompositeStatement):
    guards = Field(type=T.SelectWhenPart.list_type())
    else_statements = Field(type=T.AdaNode.list_type())
    abort_statements = Field(type=T.AdaNode.list_type())


class SelectWhenPart(AdaNode):
    choices = Field(type=T.Expr)
    statements = Field(type=T.AdaNode.list_type())


class TerminateStatement(SimpleStatement):
    pass


class PackageBody(Body):
    _macros = [child_unit(Self.package_name.name.symbol,
                          Self.package_name.scope,
                          is_body=True)]

    package_name = Field(type=T.Name)
    aspects = Field(type=T.AspectSpecification)
    decls = Field(type=T.DeclarativePart)
    statements = Field(type=T.HandledStatements)

    defining_names = Property(Self.package_name.singleton)
    defining_env = Property(Self.children_env.env_orphan)


class TaskBody(Body):
    name = Field(type=T.Name)
    aspects = Field(type=T.AspectSpecification)
    decls = Field(type=T.DeclarativePart)
    statements = Field(type=T.HandledStatements)

    defining_names = Property(Self.name.singleton)


class ProtectedBody(Body):
    name = Field(type=T.Name)
    aspects = Field(type=T.AspectSpecification)
    decls = Field(type=T.DeclarativePart)

    defining_names = Property(Self.name.singleton)


class EntryBody(Body):
    entry_name = Field(type=T.Identifier)
    index_spec = Field(type=T.EntryIndexSpec)
    parameters = Field(type=T.ParameterProfile.list_type())
    when_cond = Field(type=T.Expr)
    decls = Field(type=T.DeclarativePart)
    statements = Field(type=T.HandledStatements)

    defining_names = Property(Self.entry_name.cast(Name).singleton)


class EntryIndexSpec(AdaNode):
    id = Field(type=T.Identifier)
    subtype = Field(type=T.AdaNode)


class Subunit(AdaNode):
    name = Field(type=T.Name)
    body = Field(type=T.Body)


class ProtectedBodyStub(BodyStub):
    name = Field(type=T.Name)
    aspects = Field(type=T.AspectSpecification)

    defining_names = Property(Self.name.singleton)


class SubprogramBodyStub(BodyStub):
    overriding = Field(type=T.Overriding)
    subp_spec = Field(type=T.SubprogramSpec)
    aspects = Field(type=T.AspectSpecification)

    defining_names = Property(Self.subp_spec.name.singleton)
    # Note that we don't have to override the defining_env property here since
    # what we put in lexical environment is their SubprogramSpec child.


class PackageBodyStub(BodyStub):
    name = Field(type=T.Name)
    aspects = Field(type=T.AspectSpecification)

    defining_names = Property(Self.name.singleton)


class TaskBodyStub(BodyStub):
    name = Field(type=T.Name)
    aspects = Field(type=T.AspectSpecification)

    defining_names = Property(Self.name.singleton)


class LibraryItem(AdaNode):
    is_private = Field(type=T.BoolType)
    item = Field(type=T.BasicDecl)
