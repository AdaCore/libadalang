from __future__ import absolute_import

from langkit import compiled_types
from langkit.compiled_types import (
    ASTNode, BoolType, EnumType, Field, Struct, UserField, abstract,
    env_metadata, root_grammar_class, LongType, create_macro, LogicVarType,
    EquationType, T
)

from langkit.envs import EnvSpec
from langkit.expressions import (
    AbstractProperty, And, Or, EmptyEnv, Env, EnvGroup, Literal, No, Not,
    langkit_property, Var, Bind
)
from langkit.expressions import New
from langkit.expressions import Property
from langkit.expressions import Self
from langkit.expressions.boolean import If
from langkit.expressions.logic import Domain, Predicate, LogicAnd


def symbol_list(base_id_list):
    """
    Turn a list of BaseId into the corresponding array of symbols.

    :param AbstractExpression base_id_list: ASTList for the BaseId nodes to
        process.
    :rtype: AbstractExpression
    """
    return base_id_list.map(lambda base_id: base_id.tok.symbol)


@env_metadata
class Metadata(Struct):
    dottable_subprogram = UserField(
        BoolType, doc="Whether the stored element is a subprogram accessed "
                      "through the dot notation"
    )
    implicit_deref = UserField(
        BoolType, doc="Whether the stored element is accessed through an "
                      "implicit dereference"
    )


@abstract
@root_grammar_class
class AdaNode(ASTNode):
    """
    Root node class for the Ada grammar. This is good and necessary for several
    reasons:

    1. It will facilitate the sharing of langkit_support code if we ever have
       two libraries generated by LanguageKit in the same application.

    2. It allows to insert code specific to the ada root node, without
       polluting every LanguageKit node, and without bringing back the root
       ASTNode in the code templates.
    """

    ref_var = UserField(LogicVarType, is_private=True)
    type_var = UserField(LogicVarType, is_private=True)
    """
    Those two fields represents the result of the xref equations solving.

    TODO: They're probably not needed on every AdaNode, but are put here for
    the time being for convenience. We'll need to hoist them up the type chain
    at some point.
    """

    type_val = Property(
        Self.type_var.get_value,
        doc="""
        This will return the value of the type of this node after symbol
        resolution. NOTE: For this to be bound, resolve_symbols needs to be
        called on the appropriate parent node first.
        """
    )
    ref_val = Property(
        Self.ref_var.get_value,
        doc="""
        This will return the node this nodes references after symbol
        resolution. NOTE: For this to be bound, resolve_symbols needs to be
        called on the appropriate parent node first.
        """
    )


def child_unit(name_expr, scope_expr, env_val_expr=Self, is_body=False):
    """
    This macro will add the properties and the env specification necessary
    to make a node implement the specification of a library child unit in
    Ada, so that you can declare new childs to an unit outside of its own
    scope.

    :param AbstractExpression name_expr: The expression that will retrieve
        the name symbol for the decorated node.

    :param AbstractExpression scope_expr: The expression that will retrieve the
        scope node for the decorated node.

    :param AbstractExpression env_val_expr: The expression that will
        retrieve the environment value for the decorated node.

    :param bool is_body: Whether this unit is a body. If it is, the environment
        hook will try to make the corresponding spec's environment its parent.

    :rtype: NodeMacro
    """

    attribs = dict(
        scope=Property(scope_expr, private=True, doc="""
                       Helper property, that will return the scope of
                       definition of this child unit.
                       """),
        env_spec=EnvSpec(
            initial_env=Self.scope, add_env=True,
            add_to_env=(name_expr, env_val_expr),
            env_hook_arg=(Self if is_body else None),
        )
    )

    return create_macro(attribs)


@abstract
class BasicDecl(AdaNode):
    defining_names = AbstractProperty(type=T.Name.array_type())
    defining_name = Property(Self.defining_names.at(0))
    defining_env = Property(
        EmptyEnv, private=True,
        doc="""
        Return a lexical environment that contains entities that are accessible
        as suffixes when Self is a prefix.
        """
    )

    array_ndims = Property(
        Literal(0),
        doc="""
        If this designates an entity with an array-like interface, return its
        number of dimensions. Return 0 otherwise.
        """
    )

    is_array = Property(Self.array_ndims > 0)

    expr_type = AbstractProperty(
        type=T.TypeDecl,
        runtime_check=True,
        doc="""
        Return the type declaration corresponding to this basic declaration
        has when it is used in an expression context. For example, for this
        basic declaration::

            type Int is range 0 .. 100;

            A : Int := 12;

        the declaration of the Int type will be returned. For this
        declaration::

            type F is delta 0.01 digits 10;

            function B return F;

        expr_type will return the declaration of the type F.
        """
    )

    @langkit_property(return_type=T.TypeDecl)
    def canonical_expr_type():
        """
        Same as expr_type, but will instead return the canonical type
        declaration.
        """
        return Self.expr_type.canonical_type


@abstract
class Body(BasicDecl):
    pass


@abstract
class BodyStub(Body):
    pass


class DiscriminantSpec(AdaNode):
    ids = Field(type=T.Identifier.list_type())
    type_expr = Field(type=T.TypeExpression)
    default_expr = Field(type=T.Expr)

    env_spec = EnvSpec(add_to_env=(symbol_list(Self.ids), Self))


class TypeDiscriminant(AdaNode):
    discr_specs = Field(type=T.DiscriminantSpec.list_type())


@abstract
class TypeDef(AdaNode):
    array_ndims = Property(
        Literal(0),
        doc="""
        If this designates an array type, return its number of dimensions.
        Return 0 otherwise.
        """
    )

    is_real_type = Property(False, doc="Whether type is a real type or not.")
    is_int_type = Property(False,
                           doc="Whether type is an integer type or not.")


class EnumTypeDef(TypeDef):
    enum_literals = Field(type=T.BaseId.list_type())


class Variant(AdaNode):
    choice_list = Field(type=T.AdaNode.list_type())
    components = Field(type=T.ComponentList)


class VariantPart(AdaNode):
    discr_name = Field(type=T.Identifier)
    variant = Field(type=T.Variant.list_type())


class ComponentDecl(BasicDecl):
    ids = Field(type=T.Identifier.list_type())
    component_def = Field(type=T.ComponentDef)
    default_expr = Field(type=T.Expr)
    aspects = Field(type=T.AspectSpecification)

    env_spec = EnvSpec(add_to_env=(symbol_list(Self.ids), Self))

    defining_env = Property(
        Self.component_def.type_expr.defining_env,
        private=True,
        doc="See BasicDecl.defining_env"
    )

    defining_names = Property(Self.ids.map(lambda id: id.cast(T.Name)))

    array_ndims = Property(Self.component_def.type_expr.array_ndims)


class ComponentList(AdaNode):
    components = Field(type=T.AdaNode.list_type())
    variant_part = Field(type=T.VariantPart)


class RecordDef(AdaNode):
    components = Field(type=T.ComponentList)


class RecordTypeDef(TypeDef):
    abstract = Field(type=T.BoolType)
    tagged = Field(type=T.BoolType)
    limited = Field(type=T.BoolType)
    record_def = Field(type=T.RecordDef)


@abstract
class RealTypeDef(TypeDef):
    is_real_type = Property(True)


@abstract
class TypeDecl(BasicDecl):
    type_id = Field(type=T.Identifier)

    name = Property(Self.type_id)
    env_spec = EnvSpec(add_to_env=(Self.type_id.name.symbol, Self),
                       add_env=True)

    defining_names = Property(Self.type_id.cast(T.Name).singleton)

    is_real_type = Property(False, doc="Whether type is a real type or not.")
    is_int_type = Property(False, doc="Whether type is an integer type or not")

    @langkit_property(return_type=T.TypeDecl)
    def canonical_type():
        """
        Return the canonical type declaration for this type declaration. For
        subtypes, it will return the base type declaration.
        """
        return Self


class FullTypeDecl(TypeDecl):
    discriminants = Field(type=T.TypeDiscriminant)
    type_def = Field(type=T.TypeDef)
    aspects = Field(type=T.AspectSpecification)

    array_ndims = Property(Self.type_def.array_ndims)

    @langkit_property()
    def defining_env():
        # The environments that types define are always independent of the
        # environment in which the type is defined, hence the orphan
        # environment.
        result = Self.children_env.env_orphan

        return Self.type_def.match(
            # If this type derives from another one, it inherits the latter's
            # environment, so the following will return a copy of result whose
            # parent environment is the inheritted one.
            lambda td=DerivedTypeDef: EnvGroup(result, td.name.defining_env),

            lambda _:                 result,
        )

    is_real_type = Property(Self.type_def.is_real_type)
    is_int_type = Property(Self.type_def.is_int_type)


class FloatingPointDef(RealTypeDef):
    num_digits = Field(type=T.Expr)
    range = Field(type=T.Expr)


class OrdinaryFixedPointDef(RealTypeDef):
    delta = Field(type=T.Expr)
    range = Field(type=T.Expr)


class DecimalFixedPointDef(RealTypeDef):
    delta = Field(type=T.Expr)
    digits = Field(type=T.Expr)
    range = Field(type=T.Expr)


@abstract
class Constraint(AdaNode):
    pass


class RangeConstraint(Constraint):
    range = Field(type=T.Expr)


class DigitsConstraint(Constraint):
    digits = Field(type=T.Expr)
    range = Field(type=T.Expr)


class DeltaConstraint(Constraint):
    digits = Field(type=T.Expr)
    range = Field(type=T.Expr)


class IndexConstraint(Constraint):
    constraints = Field(type=T.AdaNode.list_type())


class DiscriminantConstraint(Constraint):
    constraints = Field(type=T.DiscriminantAssociation.list_type())


class DiscriminantAssociation(Constraint):
    ids = Field(type=T.Identifier.list_type())
    expr = Field(type=T.Expr)


class DerivedTypeDef(TypeDef):
    abstract = Field(type=T.BoolType)
    limited = Field(type=T.BoolType)
    synchronized = Field(type=T.BoolType)
    null_exclusion = Field(type=T.BoolType)
    name = Field(type=T.TypeExpression)
    constraint = Field(type=T.Constraint)
    interfaces = Field(type=T.Name.list_type())
    record_extension = Field(type=T.RecordDef)
    has_private_part = Field(type=T.BoolType)

    array_ndims = Property(Self.name.array_ndims)


class IncompleteTypeDef(TypeDef):
    is_tagged = Field(type=T.BoolType)

    # TODO: what should we return for array_ndims? Do we need to find the full
    # view?


class PrivateTypeDef(TypeDef):
    abstract = Field(type=T.BoolType)
    tagged = Field(type=T.BoolType)
    limited = Field(type=T.BoolType)

    # TODO: what should we return for array_ndims? Do we need to find the full
    # view?


class SignedIntTypeDef(TypeDef):
    range = Field(type=T.Expr)
    is_int_type = Property(True)


class ModIntTypeDef(TypeDef):
    expr = Field(type=T.Expr)
    is_int_type = Property(True)


@abstract
class ArrayIndices(AdaNode):
    ndims = AbstractProperty(
        type=LongType,
        doc="""Number of dimensions described in this node."""
    )


class UnconstrainedArrayIndices(ArrayIndices):
    list = Field(type=T.Name.list_type())

    ndims = Property(Self.list.length)


class ConstrainedArrayIndices(ArrayIndices):
    list = Field(type=T.AdaNode.list_type())

    ndims = Property(Self.list.length)


class ComponentDef(AdaNode):
    aliased = Field(type=T.BoolType)
    type_expr = Field(type=T.TypeExpression)


class ArrayTypeDef(TypeDef):
    indices = Field(type=T.ArrayIndices)
    stored_component = Field(type=T.ComponentDef)

    array_ndims = Property(Self.indices.ndims)


class InterfaceKind(EnumType):
    alternatives = ["limited", "task", "protected", "synchronized"]
    suffix = 'interface'


class InterfaceTypeDef(TypeDef):
    interface_kind = Field(type=T.InterfaceKind)
    interfaces = Field(type=T.Name.list_type())


class SubtypeDecl(TypeDecl):
    type_expr = Field(type=T.TypeExpression)
    aspects = Field(type=T.AspectSpecification)

    array_ndims = Property(Self.type_expr.array_ndims)
    defining_env = Property(Self.type_expr.defining_env)

    canonical_type = Property(Self.type_expr.designated_type.canonical_type)


class TaskDef(AdaNode):
    interfaces = Field(type=T.Name.list_type())
    public_part = Field(type=T.PublicPart)
    private_part = Field(type=T.PrivatePart)
    end_id = Field(type=T.Identifier)


class ProtectedDef(AdaNode):
    public_part = Field(type=T.PublicPart)
    private_part = Field(type=T.PrivatePart)
    end_id = Field(type=T.Identifier)


class TaskTypeDecl(BasicDecl):
    task_type_name = Field(type=T.Identifier)
    discrs = Field(type=T.TypeDiscriminant)
    aspects = Field(type=T.AspectSpecification)
    definition = Field(type=T.TaskDef)

    defining_names = Property(Self.task_type_name.cast(T.Name).singleton)


class ProtectedTypeDecl(BasicDecl):
    protected_type_name = Field(type=T.Identifier)
    discrs = Field(type=T.TypeDiscriminant)
    aspects = Field(type=T.AspectSpecification)
    interfaces = Field(type=T.Name.list_type())
    definition = Field(type=T.ProtectedDef)

    defining_names = Property(Self.protected_type_name.cast(T.Name).singleton)


class AccessDef(TypeDef):
    not_null = Field(type=T.BoolType)
    access_expr = Field(type=T.AccessExpression)
    constraint = Field(type=T.Constraint)


class FormalDiscreteTypeDef(TypeDef):
    pass


class NullComponentDecl(AdaNode):
    pass


class WithDecl(AdaNode):
    is_limited = Field(type=T.BoolType)
    is_private = Field(type=T.BoolType)
    packages = Field(type=T.Name.list_type())

    env_spec = EnvSpec(env_hook_arg=Self)


@abstract
class UseDecl(AdaNode):
    pass


class UsePkgDecl(UseDecl):
    packages = Field(type=T.Name.list_type())


class UseTypDecl(UseDecl):
    all = Field(type=T.BoolType)
    types = Field(type=T.Expr.list_type())


class TypeExpression(AdaNode):
    """
    This type will be used as a base for what represents a type expression
    in the Ada syntax tree.
    """
    null_exclusion = Field(type=T.BoolType)
    type_expr_variant = Field(type=T.TypeExprVariant)

    array_ndims = Property(Self.type_expr_variant.array_ndims)
    defining_env = Property(
        Self.type_expr_variant.defining_env, private=True,
        doc='Helper for BaseDecl.defining_env'
    )

    designated_type = Property(
        Self.type_expr_variant.designated_type,
        doc="Shortcut to get at the designated type of the type expression"
    )


@abstract
class TypeExprVariant(AdaNode):
    array_ndims = AbstractProperty(
        type=LongType,
        doc="""
        If this designates an array type, return its number of dimensions.
        Return 0 otherwise.
        """
    )
    defining_env = Property(
        EmptyEnv, private=True,
        doc='Helper for BaseDecl.defining_env'
    )

    designated_type = AbstractProperty(
        type=TypeDecl, runtime_check=True, doc="""
        Return the type designated by this type expression.
        """
    )


class TypeRef(TypeExprVariant):
    name = Field(type=T.Expr)
    constraint = Field(type=T.Constraint)

    # The name for this type has to be evaluated in the context of the TypeRef
    # node itself: we don't want to use whatever lexical environment the caller
    # is using.
    designated_type = Property(
        Self.node_env.eval_in_env(Self.name.designated_type)
    )

    array_ndims = Property(Self.designated_type.then(
        # "designated_type" may return no node for incorrect code
        lambda t: t.array_ndims,
        default_val=Literal(0)
    ))

    defining_env = Property(Self.designated_type.defining_env)


@abstract
class AccessExpression(TypeExprVariant):
    array_ndims = Property(Literal(0))
    # TODO? Should we handle defining_env here for implicit dereferencing?

    # TODO: Implement designated_type (which will need resolution of anonymous
    # access types first).


class SubprogramAccessExpression(AccessExpression):
    is_protected = Field(repr=False)
    subp_spec = Field(type=T.SubprogramSpec)


class TypeAccessExpression(AccessExpression):
    is_all = Field(type=T.BoolType)
    is_constant = Field(type=T.BoolType)
    subtype_name = Field(type=T.Expr)


class ParameterProfile(AdaNode):
    ids = Field(type=T.Identifier.list_type())
    is_aliased = Field(type=T.BoolType)
    mode = Field(type=T.InOut)
    type_expr = Field(type=T.TypeExpression)
    default = Field(type=T.Expr)
    is_mandatory = Property(Self.default.is_null)

    env_spec = EnvSpec(add_to_env=(symbol_list(Self.ids), Self))


class AspectSpecification(AdaNode):
    aspect_assocs = Field(type=T.AspectAssoc.list_type())


class BasicSubprogramDecl(BasicDecl):
    _macros = [child_unit(Self.subp_spec.name.name.symbol,
                          Self.subp_spec.name.scope,
                          Self)]

    is_overriding = Field(type=T.Overriding)
    subp_spec = Field(type=T.SubprogramSpec)

    name = Property(Self.subp_spec.name)
    defining_names = Property(Self.subp_spec.name.singleton)
    defining_env = Property(Self.subp_spec.defining_env)

    expr_type = Property(
        Self.subp_spec.returns.designated_type, doc="""
        The expr type of a subprogram declaration is the return type of the
        subprogram if the subprogram is a function.
        """
    )


class SubprogramDecl(BasicSubprogramDecl):
    aspects = Field(type=T.AspectSpecification)


class NullSubprogramDecl(BasicSubprogramDecl):
    aspects = Field(type=T.AspectSpecification)


class AbstractSubprogramDecl(BasicSubprogramDecl):
    aspects = Field(type=T.AspectSpecification)


class ExpressionFunction(BasicSubprogramDecl):
    expression = Field(type=T.Expr)
    aspects = Field(type=T.AspectSpecification)


class RenamingSubprogramDecl(BasicSubprogramDecl):
    renames = Field(type=T.RenamingClause)
    aspects = Field(type=T.AspectSpecification)


class Pragma(AdaNode):
    id = Field(type=T.Identifier)
    args = Field(type=T.PragmaArgument.list_type())


class PragmaArgument(AdaNode):
    id = Field(type=T.Identifier)
    expr = Field(type=T.Expr)


######################
# GRAMMAR DEFINITION #
######################

class InOut(EnumType):
    alternatives = ["in", "out", "inout"]
    suffix = 'way'


@abstract
class AspectClause(AdaNode):
    pass


class EnumRepClause(AspectClause):
    type_name = Field(type=T.Name)
    aggregate = Field(type=T.Aggregate)


class AttributeDefClause(AspectClause):
    attribute_expr = Field(type=T.Expr)
    expr = Field(type=T.Expr)


class RecordRepComponent(AdaNode):
    id = Field(type=T.Identifier)
    position = Field(type=T.Expr)
    range = Field(type=T.Expr)


class RecordRepClause(AspectClause):
    component_name = Field(type=T.Name)
    at_expr = Field(type=T.Expr)
    components = Field(type=T.RecordRepComponent.list_type())


class AtClause(AspectClause):
    name = Field(type=T.Expr)
    expr = Field(type=T.Expr)


class EntryDecl(BasicDecl):
    overriding = Field(type=T.Overriding)
    entry_id = Field(type=T.Identifier)
    family_type = Field(type=T.AdaNode)
    params = Field(type=T.ParameterProfile.list_type())
    aspects = Field(type=T.AspectSpecification)

    defining_names = Property(Self.entry_id.cast(T.Name).singleton)


class TaskDecl(BasicDecl):
    task_name = Field(type=T.Identifier)
    aspects = Field(type=T.AspectSpecification)
    definition = Field(type=T.TaskDef)

    defining_names = Property(Self.task_name.cast(T.Name).singleton)


class ProtectedDecl(BasicDecl):
    protected_name = Field(type=T.Identifier)
    aspects = Field(type=T.AspectSpecification)
    definition = Field(type=T.ProtectedDef)

    defining_names = Property(Self.protected_name.cast(T.Name).singleton)


class AspectAssoc(AdaNode):
    id = Field(type=T.Expr)
    expr = Field(type=T.Expr)


class NumberDecl(BasicDecl):
    ids = Field(type=T.Identifier.list_type())
    expr = Field(type=T.Expr)

    defining_names = Property(Self.ids.map(lambda id: id.cast(T.Name)))


class ObjectDecl(BasicDecl):
    ids = Field(type=T.Identifier.list_type())
    aliased = Field(type=T.BoolType)
    constant = Field(type=T.BoolType)
    inout = Field(type=T.InOut)
    type_expr = Field(type=T.AdaNode)
    default_expr = Field(type=T.Expr)
    renaming_clause = Field(type=T.RenamingClause)
    aspects = Field(type=T.AspectSpecification)

    env_spec = EnvSpec(add_to_env=(symbol_list(Self.ids), Self))

    array_ndims = Property(
        # The grammar says that the "type" field can be only a TypeExpression
        # or an ArrayTypeDef, so we have a bug somewhere if we get anything
        # else.
        Self.type_expr.cast(ArrayTypeDef).then(
            lambda array_type: array_type.array_ndims,
            default_val=(
                Self.type_expr.cast_or_raise(TypeExpression).array_ndims
            )
        ),
    )

    defining_names = Property(Self.ids.map(lambda id: id.cast(T.Name)))

    defining_env = Property(
        Self.type_expr.cast(TypeExpression).then(
            lambda te: te.defining_env,
            default_val=EmptyEnv
        )
    )

    expr_type = Property(
        # TODO: Handle anonymous arrays definitions
        Self.type_expr.cast_or_raise(TypeExpression).designated_type
    )


class PrivatePart(AdaNode):
    decls = Field(type=T.AdaNode.list_type())
    env_spec = EnvSpec(add_env=True)


class PublicPart(AdaNode):
    decls = Field(type=T.AdaNode.list_type())


class DeclarativePart(AdaNode):
    decls = Field(type=T.AdaNode.list_type())


class BasePackageDecl(BasicDecl):
    """
    Package declarations. Concrete instances of this class
    will be created in generic package declarations. Other non-generic
    package declarations will be instances of PackageDecl.

    The behavior is the same, the only difference is that BasePackageDecl
    and PackageDecl have different behavior regarding lexical environments.
    In the case of generic package declarations, we use BasePackageDecl
    which has no env_spec, and the environment behavior is handled by the
    GenericPackageDecl instance.
    """
    package_name = Field(type=T.Name)
    aspects = Field(type=T.AspectSpecification)
    public_part = Field(type=T.PublicPart)
    private_part = Field(type=T.PrivatePart)
    end_id = Field(type=T.Name)

    name = Property(Self.package_name, private=True)
    defining_names = Property(Self.name.singleton)
    defining_env = Property(Self.children_env.env_orphan)


class PackageDecl(BasePackageDecl):
    """
    Non-generic package declarations.
    """
    _macros = [child_unit(Self.package_name.name.symbol,
                          Self.package_name.scope)]


class ExceptionDecl(BasicDecl):
    """
    Exception declarations.
    """
    ids = Field(type=T.Identifier.list_type())
    renames = Field(type=T.RenamingClause)
    aspects = Field(type=T.AspectSpecification)
    defining_names = Property(Self.ids.map(lambda id: id.cast(T.Name)))


@abstract
class GenericInstantiation(BasicDecl):
    """
    Instantiations of generics.
    """
    name = Field(type=T.Name)
    generic_entity_name = Field(type=T.Name)
    parameters = Field(type=T.AdaNode)
    aspects = Field(type=T.AspectSpecification)
    defining_names = Property(Self.name.singleton)


class GenericProcedureInstantiation(GenericInstantiation):
    pass


class GenericFunctionInstantiation(GenericInstantiation):
    pass


class GenericPackageInstantiation(GenericInstantiation):
    pass


class RenamingClause(AdaNode):
    """
    Renaming clause, used everywhere renamings are valid.
    """
    renamed_object = Field(type=T.Expr)


class PackageRenamingDecl(BasicDecl):
    name = Field(type=T.Name)
    renames = Field(type=RenamingClause)
    aspects = Field(type=T.AspectSpecification)

    defining_names = Property(Self.name.singleton)


class GenericRenamingDecl(BasicDecl):
    name = Field(type=T.Name)
    renames = Field(type=T.Name)
    aspects = Field(type=T.AspectSpecification)

    defining_names = Property(Self.name.singleton)


class FormalSubpDecl(BasicDecl):
    """
    Formal subprogram declarations, in generic declarations formal parts.
    """
    subp_spec = Field(type=T.SubprogramSpec)
    is_abstract = Field(type=T.BoolType)
    default_value = Field(type=T.Expr)
    aspects = Field(type=T.AspectSpecification)

    defining_names = Property(Self.subp_spec.name.singleton)


class Overriding(EnumType):
    alternatives = ["overriding", "not_overriding", "unspecified"]
    suffix = 'kind'


class GenericSubprogramDecl(BasicDecl):
    formal_part = Field(type=T.AdaNode.list_type())
    subp_spec = Field(type=T.SubprogramSpec)
    aspects = Field(type=T.AspectSpecification)

    defining_names = Property(Self.subp_spec.name.singleton)


class GenericPackageDecl(BasicDecl):
    _macros = [child_unit(Self.package_name.name.symbol,
                          Self.package_name.scope)]

    formal_part = Field(type=T.AdaNode.list_type())
    package_decl = Field(type=BasePackageDecl)

    package_name = Property(Self.package_decl.package_name)

    defining_names = Property(Self.package_name.singleton)


def is_package(e):
    """
    Property helper to determine if an entity is a package or not.

    TODO: This current solution is not really viable, because:
    1. Having to do local imports of AdaNode subclasses is tedious.
    2. is_package could be useful in other files.

    This probably hints towards a reorganization of the types definition.

    :type e: AbstractExpression
    :rtype: AbstractExpression
    """
    return e.is_a(PackageDecl, PackageBody)


@abstract
class Expr(AdaNode):
    designated_env = AbstractProperty(
        type=compiled_types.LexicalEnvType, private=True, runtime_check=True,
        doc="""
        Returns the lexical environment designated by this name.

        If this name involves overloading, this will return a combination of
        the various candidate lexical environments.
        """
    )

    scope = AbstractProperty(
        type=compiled_types.LexicalEnvType, private=True, runtime_check=True,
        doc="""
        Returns the lexical environment that is the scope in which the
        entity designated by this name is defined/used.
        """
    )

    name = AbstractProperty(
        type=compiled_types.Token, private=True, runtime_check=True,
        doc="""
        Returns the relative name of this instance. For example,
        for a prefix A.B.C, this will return C.
        """
    )

    env_elements = AbstractProperty(
        type=compiled_types.EnvElement.array_type(), runtime_check=True,
        doc="""
        Returns the list of annotated elements in the lexical environment
        that can statically be a match for expr before overloading analysis.
        """
    )

    entities = Property(
        Self.env_elements.map(lambda e: e.el), type=AdaNode.array_type(),
        doc="""
        Same as env_elements, but return bare AdaNode instances rather than
        EnvElement instances.
        """
    )

    designated_type = AbstractProperty(
        type=TypeDecl, runtime_check=True,
        doc="""
        Assuming this expression designates a type, return this type.

        Since in Ada this can be resolved locally without any non-local
        analysis, this doesn't use logic equations.
        """
    )

    xref_equation = AbstractProperty(
        type=EquationType, runtime_check=True,
        doc="""
        This is the base property for constructing equations that, when solved,
        will resolve symbols and types for every sub expression of the
        expression you call it on. Note that if you call that on any
        expression, in some context it might lack full information and return
        multiple solutions. If you want completely precise resolution, you must
        call that on the outermost node that supports xref_equation.
        """,
        private=True
    )


class UnOp(Expr):
    op = Field(type=T.Op)
    expr = Field(type=T.Expr)


class BinOp(Expr):
    left = Field(type=T.Expr)
    op = Field(type=T.Op)
    right = Field(type=T.Expr)


class MembershipExpr(Expr):
    expr = Field(type=T.Expr)
    op = Field(type=T.Op)
    membership_exprs = Field(type=T.AdaNode.list_type())


class Aggregate(Expr):
    ancestor_expr = Field(type=T.Expr)
    assocs = Field(type=T.AggregateContent)


class CallExpr(Expr):
    name = Field(type=T.Expr)
    suffix = Field(type=T.AdaNode)

    designated_env = Property(
        Self.entities().map(lambda e: e.match(
            lambda subp=BasicSubprogramDecl: subp.defining_env,
            lambda subp=SubprogramBody:      subp.defining_env,
            lambda others:                   EmptyEnv,
        )).env_group
    )

    env_elements = Property(Self.name.env_elements)

    # CallExpr can appear in type expressions: they are used to create implicit
    # subtypes for discriminated records or arrays.
    designated_type = Property(Self.name.designated_type)

    xref_equation = Property(
        Self.name.xref_equation
        # TODO: For the moment we presume that a CallExpr in an expression
        # context necessarily has a ParamList as a suffix, but this is not
        # always true (for example, entry families calls). Handle the
        # remaining cases.
        & LogicAnd(Self.suffix.cast(T.ParamList).params.map(
            lambda pa: pa.expr.xref_equation
        ))
    )


class ParamAssoc(AdaNode):
    designator = Field(type=T.AdaNode)
    expr = Field(type=T.Expr)


class ParamList(AdaNode):
    params = Field(type=T.ParamAssoc.list_type())


class AccessDeref(Expr):
    pass


class DiamondExpr(Expr):
    pass


class OthersDesignator(AdaNode):
    pass


class AggregateMember(AdaNode):
    choice_list = Field(type=T.AdaNode.list_type())


class Op(EnumType):
    """Operation in a binary expression."""
    alternatives = ["and", "or", "or_else", "and_then", "xor", "in",
                    "not_in", "abs", "not", "pow", "mult", "div", "mod",
                    "rem", "plus", "minus", "bin_and", "eq", "neq", "lt",
                    "lte", "gt", "gte", "ellipsis"]
    suffix = 'op'


class IfExpr(Expr):
    cond_expr = Field(type=T.Expr)
    then_expr = Field(type=T.Expr)
    elsif_list = Field(type=T.ElsifExprPart.list_type())
    else_expr = Field(type=T.Expr)


class ElsifExprPart(AdaNode):
    cond_expr = Field(type=T.Expr)
    then_expr = Field(type=T.Expr)


class CaseExpr(Expr):
    expr = Field(type=T.Expr)
    cases = Field(type=T.CaseExprAlternative.list_type())


class CaseExprAlternative(Expr):
    choices = Field(type=T.AdaNode.list_type())
    expr = Field(type=T.Expr)


@abstract
class Name(Expr):

    env_for_scope = Property(
        EmptyEnv,
        doc="""
        Lexical environment this identifier represents. This is similar to
        designated_env although it handles only cases for child units and it is
        used only during the environment population pass so it does not return
        orphan environments.
        """
    )


@abstract
class SingleTokNode(Name):
    tok = Field(type=T.Token)

    name = Property(Self.tok)

    @langkit_property(return_type=BoolType)
    def matches(other=T.SingleTokNode):
        """
        Return whether this token and the "other" one are the same.
        This is only defined for two nodes that wrap symbols.

        """
        return Self.name.symbol == other.name.symbol


@abstract
class BaseId(SingleTokNode):

    env_for_scope = Property(Env.resolve_unique(Self.tok).el.match(
        lambda decl=T.PackageDecl: decl.children_env,
        lambda body=T.PackageBody: body.children_env,
        lambda others:             EmptyEnv
    ))

    designated_env = Property(
        Self.entities.map(lambda el: el.cast(BasicDecl).then(
            lambda decl: decl.defining_env
        )).env_group
    )

    scope = Property(Env)
    name = Property(Self.tok)

    # This implementation of designated_type is more permissive than the
    # "legal" one since it will skip entities that are eventually available
    # first in the env, shadowing the actual type, if they are not types. It
    # will allow to get working XRefs in simple shadowing cases.
    designated_type = Property(
        Self.entities.map(lambda e: e.cast(TypeDecl)).filter(lambda e: (
            Not(e.is_null)
        )).at(0)
    )

    @langkit_property(return_type=CallExpr)
    def parent_callexpr():
        """
        If this BaseId is the main symbol qualifying the prefix in a call
        expression, this returns the corresponding CallExpr node. Return null
        otherwise. For example::

            C (12, 15);
            ^ parent_callexpr = <CallExpr>

            A.B.C (12, 15);
                ^ parent_callexpr = <CallExpr>

            A.B.C (12, 15);
              ^ parent_callexpr = null

            C (12, 15);
               ^ parent_callexpr = null
        """
        return Self.parents.take_while(lambda p: Or(
            p.is_a(CallExpr),
            p.is_a(DottedName, BaseId) & p.parent.match(
                lambda pfx=DottedName: pfx.suffix == p,
                lambda ce=CallExpr: ce.name == p,
                lambda _: False
            )
        )).find(lambda p: p.is_a(CallExpr)).cast(CallExpr)

    @langkit_property()
    def env_elements():
        items = Var(Env.get(Self.tok))
        pc = Var(Self.parent_callexpr)

        return If(
            pc.is_null,

            # If it is not the main id in a CallExpr: either the name
            # designates something else than a subprogram, either it designates
            # a subprogram that accepts no explicit argument. So filter out
            # other subprograms.
            items.filter(
                lambda e: e.el.match(
                    lambda subp=BasicSubprogramDecl: subp.subp_spec,
                    lambda subp=SubprogramBody:      subp.subp_spec,
                    lambda others:                   No(SubprogramSpec),
                ).then(
                    lambda ss: Or(
                        e.MD.dottable_subprogram & (ss.nb_min_params == 1),
                        ss.nb_min_params == 0
                    ), default_val=True
                )
            ),

            # This identifier is the name for a called subprogram or an array.
            # So only keep:
            # * subprograms for which the actuals match;
            # * arrays for which the number of dimensions match.
            pc.suffix.cast(ParamList).then(lambda params: (
                items.filter(lambda e: e.el.match(
                    lambda subp=BasicSubprogramDecl:
                        subp.subp_spec.is_matching_param_list(params),
                    lambda subp=SubprogramBody:
                        subp.subp_spec.is_matching_param_list(params),
                    lambda o=ObjectDecl: o.array_ndims == params.params.length,
                    lambda _: True
                ))
            ), default_val=items)
        )

    xref_equation = Property(
        Domain(Self.ref_var, Self.entities)
        & Bind(Self.ref_var, Self.type_var,
               BasicDecl.fields.canonical_expr_type)
    )


class Identifier(BaseId):
    _repr_name = "Id"


class StringLiteral(BaseId):
    _repr_name = "Str"


class EnumIdentifier(Identifier):
    _repr_name = "EnumId"


class CharLiteral(BaseId):
    _repr_name = "Chr"


class NumLiteral(SingleTokNode):
    _repr_name = "Num"


class DecLiteral(NumLiteral):
    _repr_name = "Dec"

    xref_equation = Property(
        Predicate(Self.type_var, TypeDecl.fields.is_real_type)
    )


class IntLiteral(NumLiteral):
    _repr_name = "Int"

    xref_equation = Property(
        Predicate(Self.type_var, TypeDecl.fields.is_int_type)
    )


class NullLiteral(SingleTokNode):
    _repr_name = "Null"


class Attribute(SingleTokNode):
    _repr_name = "Attr"


class SingleParameter(Struct):
    name = Field(type=Identifier)
    profile = Field(type=ParameterProfile)


class ParamMatch(Struct):
    """
    Helper data structure to implement SubprogramSpec/ParamAssocList matching.

    Each value relates to one ParamAssoc.
    """
    has_matched = Field(type=BoolType, doc="""
        Whether the matched ParamAssoc a ParameterProfile.
    """)
    is_formal_opt = Field(type=BoolType, doc="""
        Whether the matched ParameterProfile has a default value (and is thus
        optional).
    """)


class SubprogramSpec(AdaNode):
    name = Field(type=T.Name)
    params = Field(type=T.ParameterProfile.list_type())
    returns = Field(type=T.TypeExpression)

    typed_param_list = Property(
        Self.params.mapcat(
            lambda profile: profile.ids.map(lambda id: (
                New(SingleParameter, name=id, profile=profile)
            ))
        ),
        doc='Collection of couples (identifier, param profile) for all'
            ' parameters'
    )

    nb_min_params = Property(
        Self.typed_param_list.filter(lambda p: p.profile.is_mandatory).length,
        type=LongType, doc="""
        Return the minimum number of parameters this subprogram can be called
        while still being a legal call.
        """
    )

    nb_max_params = Property(
        Self.typed_param_list.length, type=LongType,
        doc="""
        Return the maximum number of parameters this subprogram can be called
        while still being a legal call.
        """
    )

    @langkit_property(return_type=ParamMatch.array_type())
    def match_param_list(params=ParamList):
        """
        For each ParamAssoc in a ParamList, return whether we could find a
        matching formal in this SubprogramSpec and whether this formal is
        optional (i.e. has a default value).
        """
        typed_params = Var(Self.typed_param_list)
        no_match = Var(New(ParamMatch, has_matched=False, is_formal_opt=False))

        return params.params.map(lambda i, pa: If(
            pa.designator.is_null,

            # Positional parameter case: if this parameter has no
            # name association, make sure we have enough formals.
            typed_params.at(i).then(lambda single_param: New(
                ParamMatch,
                has_matched=True,
                is_formal_opt=Not(single_param.profile.default.is_null)
            ), no_match),

            # Named parameter case: make sure the designator is
            # actualy a name and that there is a corresponding
            # formal.
            pa.designator.cast(Identifier).then(lambda id: (
                typed_params.find(lambda p: p.name.matches(id)).then(
                    lambda p: New(
                        ParamMatch,
                        has_matched=True,
                        is_formal_opt=Not(p.profile.default.is_null)
                    ), no_match
                )
            ), no_match)
        ))

    @langkit_property(return_type=BoolType)
    def is_matching_param_list(params=ParamList):
        """
        Return whether a ParamList is a match for this SubprogramSpec, i.e.
        whether the argument count (and designators, if any) match.
        """
        match_list = Var(Self.match_param_list(params))

        return And(
            params.params.length <= Self.nb_max_params,
            match_list.all(lambda m: m.has_matched),
            match_list.filter(
                lambda m: Not(m.is_formal_opt)
            ).length == Self.nb_min_params,
        )

    @langkit_property(return_type=BoolType)
    def match_param_assoc(pa=ParamAssoc):
        """
        Return whether some parameter association matches an argument in this
        subprogram specification. Note that this matching disregards types: it
        only considers arity and designators (named parameters).
        """
        # Parameter associations can match only if there is at least one
        # formal in this spec.
        return (Self.nb_max_params > 0) & (
            # Then, all associations with no designator match, as we don't
            # consider types.
            Not(pa.designator.is_null)

            # The ones with a designator match iff the designator is an
            # identifier whose name is present in the list of formals.
            | pa.designator.cast(Identifier).then(
                lambda id: Self.typed_param_list.any(
                    lambda p: p.name.matches(id)
                )
            )
        )

    @langkit_property(return_type=compiled_types.LexicalEnvType, private=True)
    def defining_env():
        """
        Helper for BasicDecl.defining_env.
        """
        return If(Self.returns.is_null,
                  EmptyEnv,
                  Self.returns.defining_env)


class Quantifier(EnumType):
    alternatives = ["all", "some"]
    suffix = 'items'


class IterType(EnumType):
    alternatives = ["in", "of"]
    suffix = 'iter'


@abstract
class LoopSpec(AdaNode):
    pass


class ForLoopSpec(LoopSpec):
    id = Field(type=T.Identifier)
    loop_type = Field(type=T.IterType)
    is_reverse = Field(type=T.BoolType)
    iter_expr = Field(type=T.AdaNode)


class QuantifiedExpr(Expr):
    quantifier = Field(type=T.Quantifier)
    loop_spec = Field(type=T.ForLoopSpec)
    expr = Field(type=T.Expr)


class Allocator(Expr):
    subpool = Field(type=T.Expr)
    expr = Field(type=T.AdaNode)


class QualExpr(Expr):
    prefix = Field(type=T.Expr)
    suffix = Field(type=T.Expr)


@abstract
class AbstractAggregateContent(AdaNode):
    pass


class AggregateContent(AbstractAggregateContent):
    fields = Field(type=T.AggregateAssoc.list_type())


class AggregateAssoc(AdaNode):
    designator = Field(type=T.AdaNode)
    expr = Field(type=T.Expr)


class AttributeRef(Expr):
    prefix = Field(type=T.Expr)
    attribute = Field(type=T.SingleTokNode)
    args = Field(type=T.AdaNode)

    designated_type = Property(Self.prefix.designated_type)


class RaiseExpression(Expr):
    exception_name = Field(type=T.Expr)
    error_message = Field(type=T.Expr)


class DottedName(Name):
    prefix = Field(type=T.Expr)
    suffix = Field(type=T.Expr)

    designated_env = Property(
        Self.prefix.designated_env.eval_in_env(Self.suffix.designated_env)
    )

    env_for_scope = Property(Self.suffix.cast(BaseId).then(
        lambda sfx: Self.scope.eval_in_env(sfx.env_for_scope),
        default_val=EmptyEnv
    ))

    scope = Property(Self.prefix.match(
        lambda name=T.Name: name.env_for_scope,
        lambda others:      EmptyEnv
    ))

    name = Property(Self.suffix.name)

    env_elements = Property(
        Self.prefix.designated_env.eval_in_env(Self.suffix.env_elements)
    )

    # This implementation of designated_type is more permissive than the
    # "legal" one since it will skip entities that are eventually available
    # first in the env if they are not packages.
    designated_type = Property(lambda: (
        Self.prefix.entities.filter(is_package).at(0).children_env.eval_in_env(
            Self.suffix.designated_type
        )
    ))


class CompilationUnit(AdaNode):
    """Root node for all Ada analysis units."""
    prelude = Field(doc="``with``, ``use`` or ``pragma`` statements.")
    body = Field(type=T.AdaNode)
    pragmas = Field(type=T.Pragma.list_type())


class SubprogramBody(Body):
    _macros = [child_unit(Self.subp_spec.name.name.symbol,
                          Self.subp_spec.name.scope,
                          Self,
                          is_body=True)]

    overriding = Field(type=T.Overriding)
    subp_spec = Field(type=T.SubprogramSpec)
    aspects = Field(type=T.AspectSpecification)
    decls = Field(type=T.DeclarativePart)
    statements = Field(type=T.HandledStatements)
    end_id = Field(type=T.Expr)

    defining_names = Property(Self.subp_spec.name.singleton)
    defining_env = Property(Self.subp_spec.defining_env)


class HandledStatements(AdaNode):
    statements = Field(type=T.AdaNode.list_type())
    exceptions = Field(type=T.ExceptionHandler.list_type())


class ExceptionHandler(AdaNode):
    exc_name = Field(type=T.Identifier)
    catched_exceptions = Field(type=T.AdaNode.list_type())
    statements = Field(type=T.AdaNode.list_type())


@abstract
class Statement(AdaNode):

    @langkit_property(private=True, return_type=EquationType)
    def xref_equation():
        """
        This is the base property for constructing equations that, when solved,
        will resolve symbols and types for every sub expression of the
        statement you call it on. Statement is always the outermost node that
        supports xref_equation (but not the only type that can be the outermost
        node), so if you call it on a statement and then resolve the equation,
        if the code is correct Ada, you should get only one correct solution.
        """
        return No(EquationType)

    resolve_symbols = Property(
        Self.xref_equation.solve,
        doc="""
        This will resolve symbols for this statement. If the operation is
        successful, then type_var and ref_var will be bound on appropriate
        subnodes of the statement.
        """
    )


@abstract
class SimpleStatement(Statement):
    pass


@abstract
class CompositeStatement(Statement):
    pass


class CallStatement(SimpleStatement):
    call = Field(type=T.Expr)


class NullStatement(SimpleStatement):
    null_lit = Field(repr=False)


class AssignStatement(SimpleStatement):
    dest = Field(type=T.Expr)
    expr = Field(type=T.Expr)

    xref_equation = Property(
        # In some cases, only the destination will provide a potential
        # set of types, such as in the statement::
        #
        #     X := 12;
        #
        # So we want to first evaluate the destination equation, so that the
        # type of the refs can "flow" from the destination to the expression.
        Self.dest.xref_equation
        & (Self.expr.type_var == Self.dest.type_var)
        & Self.expr.xref_equation
        # TODO: Equations shouldn't be position sensitive like that. Needs a
        #  fix in Adalog, or in the equation for numbers.
    )


class GotoStatement(SimpleStatement):
    label_name = Field(type=T.Name)


class ExitStatement(SimpleStatement):
    loop_name = Field(type=T.Identifier)
    condition = Field(type=T.Expr)


class ReturnStatement(SimpleStatement):
    return_expr = Field(type=T.AdaNode)


class RequeueStatement(SimpleStatement):
    call_name = Field(type=T.Expr)
    with_abort = Field(type=T.BoolType)


class AbortStatement(SimpleStatement):
    names = Field(type=T.Expr.list_type())


class DelayStatement(SimpleStatement):
    until = Field(type=T.BoolType)
    expr = Field(type=T.Expr)


class RaiseStatement(SimpleStatement):
    exception_name = Field(type=T.Expr)
    error_message = Field(type=T.Expr)


class IfStatement(CompositeStatement):
    condition = Field(type=T.Expr)
    statements = Field(type=T.AdaNode.list_type())
    alternatives = Field(type=T.ElsifStatementPart.list_type())
    else_statements = Field(type=T.AdaNode.list_type())


class ElsifStatementPart(AdaNode):
    expr = Field(type=T.Expr)
    statements = Field(type=T.AdaNode.list_type())


class Label(SimpleStatement):
    token = Field(type=T.Token)


class WhileLoopSpec(LoopSpec):
    expr = Field(type=T.Expr)


class LoopStatement(CompositeStatement):
    name = Field(type=T.Identifier)
    spec = Field(type=T.LoopSpec)
    statements = Field(type=T.AdaNode.list_type())


class BlockStatement(CompositeStatement):
    name = Field(type=T.Identifier)
    decls = Field(type=T.AdaNode.list_type())
    statements = Field(type=T.HandledStatements)

    env_spec = EnvSpec(add_env=True)


class ExtendedReturnStatement(CompositeStatement):
    object_decl = Field(type=T.ObjectDecl)
    statements = Field(type=T.HandledStatements)


class CaseStatement(CompositeStatement):
    case_expr = Field(type=T.Expr)
    case_alts = Field(type=T.CaseStatementAlternative.list_type())


class CaseStatementAlternative(AdaNode):
    choices = Field(type=T.AdaNode.list_type())
    statements = Field(type=T.AdaNode.list_type())


class AcceptStatement(CompositeStatement):
    name = Field(type=T.Identifier)
    entry_index_expr = Field(type=T.Expr)
    parameters = Field(type=T.ParameterProfile.list_type())
    statements = Field(type=T.HandledStatements)


class SelectStatement(CompositeStatement):
    guards = Field(type=T.SelectWhenPart.list_type())
    else_statements = Field(type=T.AdaNode.list_type())
    abort_statements = Field(type=T.AdaNode.list_type())


class SelectWhenPart(AdaNode):
    choices = Field(type=T.Expr)
    statements = Field(type=T.AdaNode.list_type())


class TerminateStatement(SimpleStatement):
    pass


class PackageBody(Body):
    _macros = [child_unit(Self.package_name.name.symbol,
                          Self.package_name.scope,
                          is_body=True)]

    package_name = Field(type=T.Name)
    aspects = Field(type=T.AspectSpecification)
    decls = Field(type=T.DeclarativePart)
    statements = Field(type=T.HandledStatements)

    defining_names = Property(Self.package_name.singleton)
    defining_env = Property(Self.children_env.env_orphan)


class TaskBody(Body):
    name = Field(type=T.Name)
    aspects = Field(type=T.AspectSpecification)
    decls = Field(type=T.DeclarativePart)
    statements = Field(type=T.HandledStatements)

    defining_names = Property(Self.name.singleton)


class ProtectedBody(Body):
    name = Field(type=T.Name)
    aspects = Field(type=T.AspectSpecification)
    decls = Field(type=T.DeclarativePart)

    defining_names = Property(Self.name.singleton)


class EntryBody(Body):
    entry_name = Field(type=T.Identifier)
    index_spec = Field(type=T.EntryIndexSpec)
    parameters = Field(type=T.ParameterProfile.list_type())
    when_cond = Field(type=T.Expr)
    decls = Field(type=T.DeclarativePart)
    statements = Field(type=T.HandledStatements)

    defining_names = Property(Self.entry_name.cast(Name).singleton)


class EntryIndexSpec(AdaNode):
    id = Field(type=T.Identifier)
    subtype = Field(type=T.AdaNode)


class Subunit(AdaNode):
    name = Field(type=T.Name)
    body = Field(type=T.Body)


class ProtectedBodyStub(BodyStub):
    name = Field(type=T.Name)
    aspects = Field(type=T.AspectSpecification)

    defining_names = Property(Self.name.singleton)


class SubprogramBodyStub(BodyStub):
    overriding = Field(type=T.Overriding)
    subp_spec = Field(type=T.SubprogramSpec)
    aspects = Field(type=T.AspectSpecification)

    defining_names = Property(Self.subp_spec.name.singleton)
    # Note that we don't have to override the defining_env property here since
    # what we put in lexical environment is their SubprogramSpec child.


class PackageBodyStub(BodyStub):
    name = Field(type=T.Name)
    aspects = Field(type=T.AspectSpecification)

    defining_names = Property(Self.name.singleton)


class TaskBodyStub(BodyStub):
    name = Field(type=T.Name)
    aspects = Field(type=T.AspectSpecification)

    defining_names = Property(Self.name.singleton)


class LibraryItem(AdaNode):
    is_private = Field(type=T.BoolType)
    item = Field(type=T.BasicDecl)
